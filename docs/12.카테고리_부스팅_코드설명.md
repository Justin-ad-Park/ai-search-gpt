# 12. 카테고리 부스팅 코드 설명

이 문서는 카테고리 부스팅 로직의 **구조(클래스 관계)**와 **동작(호출 흐름)**을 코드 기준으로 설명한다.
수식/점수 공식은 `11.카테고리_부스팅.md`를 참고한다.

## 0) 타입명 구분 규칙

`SearchRequest`는 아래 2가지가 공존하므로 문서에서는 용어를 분리해 표기한다.

- `ProductSearchRequest`: 애플리케이션 요청 모델 (`com.example.aisearch.model.search.SearchRequest`)
- `EsSearchRequest`: Elasticsearch Java Client 요청 모델 (`co.elastic.clients.elasticsearch.core.SearchRequest`)

## 1) 고수준 흐름 (개념)

```mermaid
flowchart TD
    A[Search Request] --> B{hasQuery?}
    B -- yes --> C[Decide Boost Policy]
    C --> D[Build Hybrid ES Request]
    D --> E[Elasticsearch Search]
    E --> F[Map SearchResponse]
    F --> G[SearchPageResult]

    B -- no --> H[Build Filter-only ES Request]
    H --> E
```

## 2) Query 유/무 분기 Flowchart

### 2-1. Query 분기 통합

```mermaid
flowchart TD
    A[search 요청] --> B{hasQuery?}
    B -- yes --> C1[CategoryBoostingDecider.decide]
    C1 --> D1[EmbeddingService.toEmbeddingVector]
    D1 --> E1[HybridBaseQueryBuilder.build]
    E1 --> F1[ElasticsearchSearchRequestBuilder.buildHybridRequest]
    F1 --> G[ElasticsearchClient.search]

    B -- no --> C2[SearchFilterQueryBuilder.buildRootQuery]
    C2 --> D2[ElasticsearchSearchRequestBuilder.buildFilterOnlyRequest]
    D2 --> G

    G --> H[DefaultSearchResponseMapper.toPageResult]
    H --> I[SearchPageResult 반환]
```

## 3) 시퀀스 다이어그램 (호출 순서)

### 3-1. Query 있는 경우

```mermaid
sequenceDiagram
    autonumber
    actor Client
    participant S as KnnSearchStrategy
    participant D as CategoryBoostingDecider
    participant E as EmbeddingService
    participant Q as HybridBaseQueryBuilder
    participant R as ElasticsearchSearchRequestBuilder
    participant P as PainlessHybridScoreScriptFactory
    participant ES as ElasticsearchClient
    participant M as DefaultSearchResponseMapper

    Client->>S: search(productSearchRequest, pageable)
    S->>D: decide(productSearchRequest)
    D-->>S: CategoryBoostingResult

    S->>E: toEmbeddingVector(query)
    E-->>S: List<Float> queryVector

    S->>Q: build(productSearchRequest, filterQuery)
    Q-->>S: Query baseQuery

    S->>R: buildHybridRequest(..., baseQuery, decision, queryVector, ...)
    R->>P: selectScriptSource(decision)
    P-->>R: painless source
    R-->>S: EsSearchRequest

    S->>ES: search(esSearchRequest)
    ES-->>S: SearchResponse<Map>

    S->>M: toPageResult(response, pageable)
    M-->>S: SearchPageResult
    S-->>Client: SearchPageResult
```

### 3-2. Query 없는 경우

```mermaid
sequenceDiagram
    autonumber
    actor Client
    participant S as KnnSearchStrategy
    participant R as ElasticsearchSearchRequestBuilder
    participant ES as ElasticsearchClient
    participant M as DefaultSearchResponseMapper

    Client->>S: search(productSearchRequest, pageable)
    S->>R: buildFilterOnlyRequest(...)
    R-->>S: EsSearchRequest
    S->>ES: search(esSearchRequest)
    ES-->>S: SearchResponse<Map>
    S->>M: toPageResult(response, pageable)
    M-->>S: SearchPageResult
    S-->>Client: SearchPageResult
```

## 4) 클래스 다이어그램 (정적 구조)

### 4-1. Query 있는 경우 (Hybrid + Category Boost)

```mermaid
classDiagram
    class SearchStrategy {
      <<interface>>
      +search(productSearchRequest, pageable) SearchPageResult
    }

    class KnnSearchStrategy {
      -ElasticsearchClient client
      -AiSearchProperties properties
      -EmbeddingService embeddingService
      -SearchFilterQueryBuilder filterQueryBuilder
      -HybridBaseQueryBuilder hybridBaseQueryBuilder
      -ElasticsearchSearchRequestBuilder searchRequestBuilder
      -DefaultSearchResponseMapper searchResponseMapper
      -CategoryBoostingDecider categoryBoostingDecider
      +search(productSearchRequest, pageable) SearchPageResult
    }

    class CategoryBoostingDecider {
      -CategoryBoostRules categoryBoostRules
      +decide(productSearchRequest) CategoryBoostingResult
    }

    class CategoryBoostingResult {
      +applyCategoryBoost() boolean
      +sortOptions() List~SortOptions~
      +categoryBoostById() Map~String,Double~
    }

    class CategoryBoostRules {
      <<interface>>
      +findByKeyword(keyword) Optional~Map~
    }

    class JsonCategoryBoostRules

    class CategoryBoostBetaTuner {
      +DEFAULT_BETA double
      +getBeta() double
      +setBeta(value)
      +reset()
    }

    class EmbeddingService {
      <<interface>>
      +toEmbeddingVector(text) List~Float~
      +dimensions() int
    }

    class SearchFilterQueryBuilder {
      +buildFilterQuery(productSearchRequest) Optional~Query~
      +buildRootQuery(productSearchRequest) Query
    }

    class HybridBaseQueryBuilder {
      +build(productSearchRequest, filterQuery) Query
    }

    class ElasticsearchSearchRequestBuilder {
      +buildHybridRequest(...) EsSearchRequest
      +buildFilterOnlyRequest(...) EsSearchRequest
    }

    class PainlessHybridScoreScriptFactory {
      +selectScriptSource(decision) String
    }

    class DefaultSearchResponseMapper {
      +toPageResult(response, pageable) SearchPageResult
    }

    SearchStrategy <|.. KnnSearchStrategy
    CategoryBoostRules <|.. JsonCategoryBoostRules

    KnnSearchStrategy --> CategoryBoostingDecider
    KnnSearchStrategy --> EmbeddingService
    KnnSearchStrategy --> SearchFilterQueryBuilder
    KnnSearchStrategy --> HybridBaseQueryBuilder
    KnnSearchStrategy --> ElasticsearchSearchRequestBuilder
    KnnSearchStrategy --> DefaultSearchResponseMapper

    CategoryBoostingDecider --> CategoryBoostRules
    CategoryBoostingDecider ..> CategoryBoostingResult
    ElasticsearchSearchRequestBuilder --> CategoryBoostBetaTuner
    ElasticsearchSearchRequestBuilder --> PainlessHybridScoreScriptFactory
```

### 4-2. Query 없는 경우 (Filter-only)

```mermaid
classDiagram
    class SearchStrategy {
      <<interface>>
      +search(productSearchRequest, pageable) SearchPageResult
    }

    class KnnSearchStrategy {
      -SearchFilterQueryBuilder filterQueryBuilder
      -ElasticsearchSearchRequestBuilder searchRequestBuilder
      -DefaultSearchResponseMapper searchResponseMapper
      +search(productSearchRequest, pageable) SearchPageResult
    }

    class SearchFilterQueryBuilder {
      +buildRootQuery(productSearchRequest) Query
    }

    class ElasticsearchSearchRequestBuilder {
      +buildFilterOnlyRequest(indexName, rootQuery, from, size) EsSearchRequest
    }

    class DefaultSearchResponseMapper {
      +toPageResult(response, pageable) SearchPageResult
    }

    SearchStrategy <|.. KnnSearchStrategy
    KnnSearchStrategy --> SearchFilterQueryBuilder
    KnnSearchStrategy --> ElasticsearchSearchRequestBuilder
    KnnSearchStrategy --> DefaultSearchResponseMapper
```

## 5) 클래스별 핵심 책임

- `KnnSearchStrategy`: 검색 분기/오케스트레이션
- `CategoryBoostingDecider`: 부스팅 적용 여부 + 최종 정렬 결정
- `ElasticsearchSearchRequestBuilder`: ES 요청 조립(script params, sort, paging, min_score)
- `PainlessHybridScoreScriptFactory`: 점수 계산 스크립트 source 제공
- `HybridBaseQueryBuilder`: 하이브리드 base bool 쿼리 생성
- `DefaultSearchResponseMapper`: ES 응답 -> API 응답 매핑
- `CategoryBoostBetaTuner`: beta 런타임 조정

## 6) 리팩터링 포인트 요약

- `KnnSearchStrategy`에서 script 문자열/요청 조립/응답 매핑 책임 분리
- 구조 분리 후, 전략 클래스는 "흐름 제어"에 집중
- 변경 시 수정 지점이 명확해져 유지보수성과 테스트 안정성 개선

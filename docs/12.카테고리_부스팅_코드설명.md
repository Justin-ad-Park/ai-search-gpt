# 12. 카테고리 부스팅 코드 설명

이 문서는 카테고리 부스팅이 코드에 어떻게 구현되어 있는지 설명한다.
- 클래스별 책임
- 호출 흐름
- 리팩터링 포인트

수식/연산 공식은 `11.카테고리_부스팅.md`를 참고한다.

## 1) 패키지/클래스 구성

## 1-1. categoryboost 패키지
위치:
- `src/main/java/com/example/aisearch/service/search/categoryboost`

핵심 클래스:
1. `api/CategoryBoostRules`
- 룰 조회 계약

2. `api/CategoryBoostRulesReloader`
- 룰 재로딩 계약

3. `policy/CategoryBoostingDecider`
- 부스팅 적용 여부/최종 정렬 결정

4. `policy/CategoryBoostingResult`
- 결정 결과 DTO (`applyCategoryBoost`, `searchSortOption`, `categoryBoostById`)

5. `policy/CategoryBoostBetaTuner`
- beta 관리 (`DEFAULT_BETA`, `getBeta`, `setBeta`, `reset`)

6. `store/JsonCategoryBoostRules`
- JSON 룰 로딩/캐시/재로딩 구현

## 1-2. 전략 계층(연결 지점)
카테고리 부스팅 정책을 실제 검색 요청에 반영하는 클래스:

1. `strategy/KnnSearchStrategy`
- 검색 흐름 오케스트레이션

2. `query/HybridBaseQueryBuilder`
- 하이브리드 베이스 bool 쿼리 생성

3. `strategy/script/PainlessHybridScoreScriptFactory`
- script source 문자열 선택/제공

4. `strategy/request/ElasticsearchSearchRequestBuilder`
- ES `SearchRequest` 조립 (hybrid/filter-only)

5. `strategy/mapper/DefaultSearchResponseMapper`
- ES 응답 -> 애플리케이션 응답 변환

## 2) 주요 흐름

1. 컨트롤러에서 `SearchRequest` 생성/정규화
2. `KnnSearchStrategy.search(...)` 진입
3. query 유무에 따라 분기
- query 있음: `vectorScoreSearch`
- query 없음: `filterOnlySearch`

4. query 있는 경우
- `CategoryBoostingDecider.decide(request)`로 적용 여부 결정
- `EmbeddingService.embed(query)`로 query vector 생성
- `HybridBaseQueryBuilder.build(...)`로 베이스 쿼리 생성
- `ElasticsearchSearchRequestBuilder.buildHybridRequest(...)`로 ES 요청 생성
- `client.search(...)` 실행
- `DefaultSearchResponseMapper.toPageResult(...)`로 반환 변환

5. query 없는 경우
- `SearchFilterQueryBuilder.buildRootQuery(...)`
- `ElasticsearchSearchRequestBuilder.buildFilterOnlyRequest(...)`
- `client.search(...)`
- `DefaultSearchResponseMapper.toPageResult(...)`

## 3) 각 클래스의 경계(왜 이렇게 나눴는가)

1. `CategoryBoostingDecider`
- "적용 여부를 결정"하는 정책 책임만 가진다.
- 점수 계산은 하지 않는다.

2. `PainlessHybridScoreScriptFactory`
- 점수 계산식 문자열 제공만 담당한다.

3. `ElasticsearchSearchRequestBuilder`
- script params 주입, 정렬/페이징/min_score 구성 등 요청 조립 책임 집중.

4. `KnnSearchStrategy`
- 오케스트레이션(순서 제어)만 수행.
- 세부 알고리즘/조립/매핑 구현 디테일은 위임.

## 4) 최근 리팩터링 포인트

1. `KnnSearchStrategy` 내부 script 문자열 상수 제거
- `PainlessHybridScoreScriptFactory`로 이동

2. 하이브리드 베이스 쿼리 생성 분리
- `HybridBaseQueryBuilder` 도입

3. ES 요청 조립 분리
- `ElasticsearchSearchRequestBuilder` 도입

4. 응답 매핑 분리
- `DefaultSearchResponseMapper` 도입

5. 벡터 포맷 단순화
- `EmbeddingService.embed(...)`가 `List<Float>`를 직접 반환하도록 변경
- 중간 변환 단계 제거

## 5) 읽기 순서 추천

1. `SearchRequest`
2. `CategoryBoostingDecider` + `CategoryBoostingResult`
3. `KnnSearchStrategy`
4. `HybridBaseQueryBuilder`
5. `ElasticsearchSearchRequestBuilder`
6. `PainlessHybridScoreScriptFactory`
7. `DefaultSearchResponseMapper`

## 6) 관련 테스트

1. `CategoryBoostingDeciderTest`
2. `JsonCategoryBoostRulesTest`
3. `CategoryBoostingTest`
4. `KnnSearchRequestSerializationTest`
5. `SynonymsRestClientIntegrationTest`

## 7) 추가 설명이 필요한 지점(권장 보강)

1. `KnnSearchRequestSerializationTest`
- 테스트 목적이 "요청 구조 직렬화 검증"인지 "점수식 검증"인지를 주석으로 분리 설명

2. `ElasticsearchSearchRequestBuilder`
- hybrid/filter-only 빌드의 분기 의도를 메서드 주석으로 명시

3. `CategoryBoostBetaTuner`
- 운영에서 beta 조정 시 기대 효과(정밀도/재현율 트레이드오프) 문서화

4. `EmbeddingService`
- `embed` 반환 타입이 `List<Float>`인 이유(ES 전용 경로 최적화) 명시

# 리팩토링 작업 정리 (초급 개발자용)

이 문서는 실제 코드 변경 내용을 기반으로, 리팩토링 전/후를 비교하며 이유와 효과를 설명합니다.
각 섹션은 “왜 바꿨는지 → 무엇이 달라졌는지 → 결과” 순서로 읽을 수 있게 구성했습니다.

---

## 1) ElasticsearchAutoConnector 책임 분리

### 왜 바꿨나?
- 한 클래스가 **포트포워딩 판단, kubectl 검사/호출, 비밀번호 로딩, URL 조합**까지 모두 담당하고 있었습니다.
- 이런 구조는 변경 이유가 많아져서 유지보수가 어려워지고, 테스트도 복잡해집니다.

### Before (핵심 부분)
```java
public ConnectionInfo resolve(AiSearchProperties properties, AiSearchK8sProperties k8sProperties) {
    URI uri = URI.create(properties.elasticsearchUrl());
    String username = properties.username();
    String password = properties.password();

    if (!k8sProperties.autoPortForward() || !isLocalHost(uri.getHost())) {
        return new ConnectionInfo(uri.toString(), username, password);
    }

    try {
        ElasticsearchK8sHelper.requireKubectl();

        String namespace = k8sProperties.namespace();
        String serviceName = k8sProperties.serviceName();
        if (serviceName == null || serviceName.isBlank()) {
            serviceName = ElasticsearchK8sHelper.findEsHttpService(namespace);
        }

        if (password == null || password.isBlank() || "password".equals(password)) {
            password = ElasticsearchK8sHelper.readElasticPassword(
                    namespace,
                    k8sProperties.secretName()
            );
            log.info("[ES_AUTO] elastic password loaded from secret {}", k8sProperties.secretName());
        }

        ensurePortForward(namespace, serviceName, k8sProperties.localPort(), k8sProperties.remotePort());
        String scheme = uri.getScheme() == null ? "http" : uri.getScheme();
        String resolvedUrl = scheme + "://localhost:" + k8sProperties.localPort();
        log.info("[ES_AUTO] using port-forwarded url {}", resolvedUrl);
        return new ConnectionInfo(resolvedUrl, username, password);
    } catch (Exception e) {
        log.warn("[ES_AUTO] port-forward failed, falling back to {}", uri, e);
        return new ConnectionInfo(uri.toString(), username, password);
    }
}
```

### After (핵심 부분)
```java
public ConnectionInfo resolve(AiSearchProperties properties, AiSearchK8sProperties k8sProperties) {
    URI uri = URI.create(properties.elasticsearchUrl());
    String username = properties.username();
    String password = properties.password();

    if (!portForwardDecision.shouldAutoForward(k8sProperties, uri)) {
        return new ConnectionInfo(uri.toString(), username, password);
    }

    try {
        k8sPortForwarder.requireKubectl();

        String namespace = k8sProperties.namespace();
        String serviceName = k8sPortForwarder.resolveServiceName(namespace, k8sProperties.serviceName());

        password = passwordProvider.resolvePassword(namespace, k8sProperties.secretName(), password);

        k8sPortForwarder.ensurePortForward(
                namespace,
                serviceName,
                k8sProperties.localPort(),
                k8sProperties.remotePort()
        );
        String resolvedUrl = urlBuilder.buildLocalUrl(uri, k8sProperties.localPort());
        return new ConnectionInfo(resolvedUrl, username, password);
    } catch (Exception e) {
        log.warn("[ES_AUTO] port-forward failed, falling back to {}", uri, e);
        return new ConnectionInfo(uri.toString(), username, password);
    }
}
```

### 무엇이 좋아졌나?
- **책임 분리(SRP)**: 판단, 포워딩, 패스워드 로딩, URL 생성이 각각 클래스로 분리됨
- 테스트하기 쉬움: 작은 단위로 교체/검증 가능

관련 파일:
- `src/main/java/com/example/aisearch/support/PortForwardDecision.java`
- `src/main/java/com/example/aisearch/support/K8sPortForwarder.java`
- `src/main/java/com/example/aisearch/support/ElasticPasswordProvider.java`
- `src/main/java/com/example/aisearch/support/ElasticsearchUrlBuilder.java`

---

## 2) 임베딩 모델 로딩 책임 분리

### 왜 바꿨나?
- `DjlEmbeddingService`가 **모델 경로/URL 선택**, **정규화**까지 모두 담당하고 있었습니다.
- 모델 선택 로직과 임베딩 정규화 로직은 다른 관심사이므로 분리하는 것이 좋습니다.

### Before (핵심 부분)
```java
String modelPath = properties.embeddingModelPath();
if (modelPath != null && !modelPath.isBlank() && !"__NONE__".equalsIgnoreCase(modelPath.trim())) {
    Resource resource = resourceLoader.getResource(modelPath);
    var resolvedPath = resource.getFile().toPath();
    log.info("[EMBED_MODEL] using model path: {} -> {}", modelPath, resolvedPath);
    criteria.optModelPath(resolvedPath);
    criteria.optTranslatorFactory(new TextEmbeddingTranslatorFactory());
} else {
    String modelUrl = properties.embeddingModelUrl();
    log.info("[EMBED_MODEL] using model url: {}", modelUrl);
    criteria.optModelUrls(modelUrl);
}

float[] raw = predictRaw(text);
return l2Normalize(raw);
```

### After (핵심 부분)
```java
EmbeddingModelSource modelSource = modelSourceResolver.resolve(properties, resourceLoader);
if (modelSource.isPathBased()) {
    criteria.optModelPath(modelSource.modelPath());
    if (modelSource.requiresTranslatorFactory()) {
        criteria.optTranslatorFactory(new ai.djl.huggingface.translator.TextEmbeddingTranslatorFactory());
    }
} else {
    criteria.optModelUrls(modelSource.modelUrl());
}

float[] raw = predictRaw(text);
return embeddingNormalizer.l2Normalize(raw);
```

### 무엇이 좋아졌나?
- 모델 소스 선택 로직이 별도 클래스로 이동 (SRP)
- 정규화 알고리즘도 독립적으로 관리 가능

관련 파일:
- `src/main/java/com/example/aisearch/service/EmbeddingModelSourceResolver.java`
- `src/main/java/com/example/aisearch/service/EmbeddingNormalizer.java`
- `src/main/java/com/example/aisearch/service/EmbeddingModelSource.java`

---

## 3) 색인 파이프라인 분리

### 왜 바꿨나?
- `ProductIndexingService`가 **문서 매핑, 벌크 인덱싱 실행**까지 담당하고 있었습니다.
- 색인 문서 형태가 바뀌면 서비스 전체가 같이 변경됩니다.

### Before (핵심 부분)
```java
BulkRequest.Builder bulkBuilder = new BulkRequest.Builder().index(properties.indexName());

for (FoodProduct food : foods) {
    float[] embedding = embeddingService.embed(food.toEmbeddingText());
    List<Float> vector = toFloatList(embedding);

    Map<String, Object> doc = new HashMap<>();
    doc.put("id", food.getId());
    doc.put("product_name", food.getProductName());
    doc.put("category", food.getCategory());
    doc.put("description", food.getDescription());
    doc.put("product_vector", vector);

    bulkBuilder.operations(op -> op
            .index(idx -> idx
                    .id(food.getId())
                    .document(doc)
            )
    );
}

var response = client.bulk(bulkBuilder.refresh(Refresh.WaitFor).build());
```

### After (핵심 부분)
```java
List<IndexDocument> documents = foods.stream()
        .map(food -> documentMapper.toIndexDocument(
                food,
                embeddingService.embed(food.toEmbeddingText())
        ))
        .collect(Collectors.toList());

return bulkIndexingExecutor.bulkIndex(properties.indexName(), documents);
```

### 무엇이 좋아졌나?
- 문서 변환 로직과 ES 실행 로직이 분리됨
- 색인 구조 변경이 쉬움

관련 파일:
- `src/main/java/com/example/aisearch/service/FoodProductDocumentMapper.java`
- `src/main/java/com/example/aisearch/service/BulkIndexingExecutor.java`
- `src/main/java/com/example/aisearch/service/IndexDocument.java`

---

## 4) 검색 전략(Strategy) 분리

### 왜 바꿨나?
- `VectorSearchService`가 검색 구현까지 직접 갖고 있어 확장이 어려웠습니다.
- 향후 하이브리드 검색, 필터 기반 검색 등을 넣기 어려운 구조였습니다.

### Before (핵심 부분)
```java
SearchResponse<Map> response = client.search(s -> s
        .index(properties.indexName())
        .knn(knn -> knn
                .field("product_vector")
                .queryVector(queryVector)
                .k((long) size)
                .numCandidates(numCandidates)
        )
        .size(size),
        Map.class
);
```

### After (핵심 부분)
```java
public List<SearchHitResult> search(String query, int size) {
    return searchStrategy.search(query, size);
}
```

### 무엇이 좋아졌나?
- 검색 구현을 교체할 수 있는 구조(Strategy 패턴)
- 서비스는 “무엇을 할지”만 알고 “어떻게 할지”는 전략이 담당

관련 파일:
- `src/main/java/com/example/aisearch/service/SearchStrategy.java`
- `src/main/java/com/example/aisearch/service/KnnSearchStrategy.java`

---

## 5) 인덱스 매핑 템플릿 외부화

### 왜 바꿨나?
- 매핑 JSON이 코드 문자열로 들어 있어 수정이 어려웠습니다.
- JSON 변경 시 코드 수정/컴파일이 필요합니다.

### Before (핵심 부분)
```java
return """
        {
          "settings": {
            "number_of_shards": 1,
            "number_of_replicas": 0
          },
          "mappings": {
            "properties": {
              "id": {"type": "keyword"},
              "product_name": {"type": "text"},
              "category": {"type": "keyword"},
              "description": {"type": "text"},
              "product_vector": {
                "type": "dense_vector",
                "dims": %d,
                "index": true,
                "similarity": "cosine"
              }
            }
          }
        }
        """.formatted(vectorDimensions);
```

### After (핵심 부분)
```java
String template = loadTemplate();
return template.replace(DIMS_PLACEHOLDER, String.valueOf(vectorDimensions));
```

```json
{
  "settings": {
    "number_of_shards": 1,
    "number_of_replicas": 0
  },
  "mappings": {
    "properties": {
      "id": {"type": "keyword"},
      "product_name": {"type": "text"},
      "category": {"type": "keyword"},
      "description": {"type": "text"},
      "product_vector": {
        "type": "dense_vector",
        "dims": __DIMS__,
        "index": true,
        "similarity": "cosine"
      }
    }
  }
}
```

### 무엇이 좋아졌나?
- JSON 수정이 쉬워짐 (리소스 파일만 수정)
- 코드 가독성 향상

관련 파일:
- `src/main/java/com/example/aisearch/service/IndexSchemaBuilder.java`
- `src/main/resources/es/index-mapping.json`

---

## 6) 배치 전용 엔트리 정리 (프로파일 기반)

### 왜 바꿨나?
- 별도의 메인 클래스가 존재하면 실행 경로가 늘어나고 관리가 어려워집니다.
- Spring Profile로 구동 옵션만 분리하면 유지보수가 쉽습니다.

### Before (핵심 부분)
별도의 배치 전용 메인 클래스를 만들어, 시스템 프로퍼티를 직접 주입하고 웹 서버를 비활성화했습니다.
```java
public class IndexingApplication {
    public static void main(String[] args) {
        System.setProperty("ai-search.bootstrap-index", "true");
        SpringApplication application = new SpringApplication(AiSearchGptApplication.class);
        application.setWebApplicationType(WebApplicationType.NONE);
        application.run(args);
    }
}
```

### After (핵심 부분)
메인 클래스는 `AiSearchGptApplication` 하나만 유지하고, 배치 실행에 필요한 옵션은 프로파일 설정으로 분리했습니다.
```java
@SpringBootApplication
@EnableConfigurationProperties({AiSearchProperties.class, AiSearchK8sProperties.class})
public class AiSearchGptApplication {
    public static void main(String[] args) {
        SpringApplication.run(AiSearchGptApplication.class, args);
    }
}
```

```yaml
# application-indexing.yml
ai-search:
  bootstrap-index: true

spring:
  main:
    web-application-type: none
```

### 무엇이 좋아졌나?
- 실행 방법이 설정으로 통일됨
- 메인 클래스 수 감소
- 배치 실행 여부를 코드가 아닌 설정으로 제어 (환경별 전환 용이)

실행 예시:
```
SPRING_PROFILES_ACTIVE=indexing ./gradlew bootRun
```

---

## 정리
- 리팩토링의 핵심은 **“책임을 작게 나누고, 변경 이유를 분리하는 것”**입니다.
- 코드가 길어지는 대신 이해하기 쉬워지고, 테스트/확장이 쉬워집니다.

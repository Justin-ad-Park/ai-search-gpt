# 11. 카테고리 부스팅 가이드 🧭

> 📌 핵심: 카테고리 부스팅은 "검색어가 특정 키워드와 정확히 일치할 때" 해당 카테고리 상품을 위로 올리는 랭킹 보정입니다.
> ⚠️ 주의: 부분일치/contains를 허용하면 오탐이 늘어나 검색 품질이 흔들립니다.
> ✅ 권장: `trim + equals` 규칙을 고정하고, 불일치 시 기본 정렬(`RELEVANCE_DESC`)로 안전하게 되돌립니다.

이 문서는 카테고리 부스팅을 처음 접하는 개발자도 이해할 수 있도록,
"언제 발동되는지", "어떻게 점수가 바뀌는지", "코드 어디를 보면 되는지"를 중심으로 설명합니다.

## 0. 카테고리 부스팅이란?
일반 검색 점수(벡터+텍스트) 위에 "카테고리 가산점"을 더하는 방식입니다.

예시:
- 사용자가 `사과`를 검색
- 키워드 규칙에 `사과 -> 과일(categoryId=4)`가 있으면
- 과일 카테고리 문서에 추가 점수를 주어 상단 노출 가능성을 높입니다.

## 1. 언제 부스팅이 적용되나?
다음 3가지가 모두 만족될 때만 적용합니다.

1. 정렬 옵션이 `CATEGORY_BOOSTING_DESC`
2. 검색어가 null/blank가 아님
3. `query.trim()` 값이 부스팅 키워드와 `equals` 일치

하나라도 불만족하면 부스팅 미적용, 대체 정렬 조건(`RELEVANCE_DESC`)으로 fallback(대비, 대체) 합니다.
정확히는 다음과 같습니다.

- `sortOption != CATEGORY_BOOSTING_DESC`: 부스팅 미적용 + 요청 정렬 유지(예: `PRICE_ASC`)
- `sortOption == CATEGORY_BOOSTING_DESC`인데 query가 없거나 규칙 불일치: 부스팅 미적용 + `RELEVANCE_DESC` fallback

## 2. 현재 룰 데이터
파일:
- `src/main/resources/data/category_boosting.json`

현재 샘플:

| 검색어 | 카테고리 ID | 카테고리명 | 부스팅 점수 |
|---|---:|---|---:|
| 간식 | 1 | 간식∙음료 | +0.20 |
| 간식 | 2 | 간편식 | +0.10 |
| 간식 | 8 | 쌀∙견과 | +0.10 |
| 복숭아 | 4 | 과일 | +0.20 |
| 사과 | 4 | 과일 | +0.20 |
| 생선 | 7 | 수산 | +0.20 |
| 오징어 | 7 | 수산 | +0.20 |
| 고등어 | 7 | 수산 | +0.20 |


## 3. 점수 계산 개념
기본 검색은 `script_score`를 사용합니다.

기본 점수:
- `vectorScore` (임베딩 유사도)
- `lexicalScore` (텍스트 매칭 점수)

부스팅 적용 시:
- 위 기본 점수에 `categoryBoostById[categoryId]`를 더함

정렬:
- `_score desc`, `id asc`

## 4. 임계치(vector min)는 어디서 관리하나?
카테고리 룰 JSON이 아니라 설정 파일에서 관리합니다.

- 설정: `src/main/resources/application.yml`
- 키: `ai-search.min-score-threshold`
- 기본값: `${AI_SEARCH_MIN_SCORE:0.74}`

즉, `category_boosting.json`에는 임계치 관련 키(`vectorMin`, `defaultVectorMin`)를 넣지 않습니다.

## 5. 코드 흐름 한눈에 보기
주요 파일:
- `src/main/java/com/example/aisearch/model/search/SearchSortOption.java`
```java
    },
    CATEGORY_BOOSTING_DESC {
        @Override
        public List<SortOptions> toSortOptions() {
            return List.of(
                    scoreSort(SortOrder.Desc),
                    fieldSort("id", SortOrder.Asc)
            );
        }
```

- `src/main/java/com/example/aisearch/service/search/strategy/KnnSearchStrategy.java`
```java
@Component
public class KnnSearchStrategy implements SearchStrategy {

    private static final String SCRIPT_COMMON = """
            double vectorScore = (cosineSimilarity(params.query_vector, 'product_vector') + 1.0) / 2.0;
            double lexicalScore = Math.min(_score, 5.0) / 5.0;
            double categoryBoost = 0.0;
            """;

    private static final String CATEGORY_BOOST_BLOCK = """
            if (doc['categoryId'].size() != 0) {
              String categoryKey = String.valueOf(doc['categoryId'].value);
              def rawBoost = params.category_boost_by_id.get(categoryKey);
              if (rawBoost != null) {
                categoryBoost = ((Number) rawBoost).doubleValue();
              }
            }
            """;

    private static final String SCRIPT_RETURN_BLOCK = """
            return Math.min(1.0, 0.9 * vectorScore + 0.1 * lexicalScore + categoryBoost + 0.1);
            """;

    // 중복 제거 : Elastic Search에 쿼리로 넘기는 계산 로직의 중복을 제거
    //          한 곳에 로직을 모아 관리 일원화 
    private static final String BASE_SCRIPT = SCRIPT_COMMON + SCRIPT_RETURN_BLOCK;
    private static final String CATEGORY_BOOST_SCRIPT = SCRIPT_COMMON + CATEGORY_BOOST_BLOCK + SCRIPT_RETURN_BLOCK;
```



흐름:
1. 요청 진입 시 `SearchRequest`에서 query를 `trim`
2. `sortOption == null`이면 `RELEVANCE_DESC`로 기본화
3. `query == null && sortOption == CATEGORY_BOOSTING_DESC`이면 `RELEVANCE_DESC`로 정규화
4. 검색어가 있으면 `KnnSearchStrategy#vectorScoreSearch`에서 `CategoryBoostingDecider`로 부스팅 적용 여부 판단
5. trim된 query를 룰 키워드와 `equals` 비교해 일치하면 category boost 스크립트 실행
6. `CATEGORY_BOOSTING_DESC` 요청인데 query 없음/규칙 불일치면 `RELEVANCE_DESC` fallback
7. 검색어가 없으면 `KnnSearchStrategy#filterOnlySearch`에서 요청 정렬(`request.sortOption()`)만 적용

## 5-1. 최근 코드 반영 사항
- `filterOnlySearch`는 카테고리 부스팅 결정을 하지 않고, `request.sortOption().toSortOptions()`로 정렬만 적용합니다.
- `SearchRequest`에서 `query`가 없을 때 `CATEGORY_BOOSTING_DESC`를 `RELEVANCE_DESC`로 미리 정규화합니다.
- `CategoryBoostingResult` 정적 팩토리 메서드 이름은 `withoutBoost` / `withBoost`를 사용합니다.

## 6. 왜 equals만 허용하나?
`contains`/부분일치로 확장하면 의도치 않은 부스팅이 자주 발생합니다.

예시:
- `간식추천`, `사과즙선물`, `고등어구이밀키트`
- 이런 조합어까지 무조건 부스팅되면 실제 연관도보다 카테고리 가산점이 과도하게 작동할 수 있습니다.

그래서 운영 안정성을 위해 `trim + equals`를 기본 정책으로 둡니다.

## 7. 테스트 체크포인트
- `" 간식 "` 입력 시 trim 후 `간식`으로 일치되어 부스팅되는가
- `"간식추천"`은 일치하지 않아 fallback 되는가
- `sort=CATEGORY_BOOSTING_DESC, q=사과`에서 과일 카테고리 우대가 반영되는가
- `sort=CATEGORY_BOOSTING_DESC, q=오징어`에서 수산 카테고리 우대가 반영되는가
- `PRICE_ASC/PRICE_DESC` 기존 동작이 유지되는가

---

필요하면 다음 단계로, 이 문서에 "요청/응답 예시(JSON)"와 "실패 케이스 디버깅 가이드"를 추가할 수 있습니다.

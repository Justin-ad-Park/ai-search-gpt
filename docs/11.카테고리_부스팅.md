# 11. 카테고리 부스팅 공식 가이드

이 문서는 "카테고리 부스팅 점수가 어떻게 계산되는지"를 수식/처리 순서 중심으로 설명한다.
코드 구조(클래스 책임, 리팩터링 포인트)는 `12.카테고리_부스팅_코드설명.md`에서 다룬다.

## 카테고리 부스팅이란?
검색 키워드와 연관이 높은 카테고리의 상품이 검색 결과의 상단에 노출될 수 있도록 카테고리 연관 키워드의 랭킹을 조정하는 것

1. 카테고리 부스팅 데이터 구성 예

| 카테고리 | 키워드 | 부스팅 점수 |
|----|-----|--------|
| 과일 | 사과  | 0.3    |
| 과일 | 복숭아 | 0.3    |
| 수산 | 고등어 | 0.2    |
| 수산 | 갈치  | 0.2    |

- "사과"를 검색했을 때 
  - 사과잼, 사과 쥬스가 인기도 점수가 높아도 "과일" 카테고리의 사과가 더 상위에 검색된다.


## 1) 적용 조건
카테고리 부스팅은 아래 조건을 모두 만족할 때만 적용된다.

1. 정렬 옵션이 `CATEGORY_BOOSTING_DESC`
2. query가 null/blank가 아님
3. `query.trim()`이 룰 키워드와 `equals` 일치

불일치 시:
- 부스팅 미적용
- `CATEGORY_BOOSTING_DESC` 요청이었다면 `RELEVANCE_DESC` fallback(대안)
  - 실제 쇼핑몰 서비스에서는 카테고리 부스팅순(`CATEGORY_BOOSTING_DESC`)으로 별도 정렬 조건을 제공하지 않고
  - 인기도순(`POPULALITY_DESC`)에 카테고리 부스팅 계산식을 넣어서 처리한다.
  - 본 프로젝트에서는 카테고리 부스팅의 이해를 위해 인기도 점수 체계를 사용하지 않고, 카테고리 부스팅 + 연관도 점수를 사용

## 2) 점수 계산식

```json
{
  "min_score": 0.71,
  "query": {
    "script_score": {
      "query": {
        "bool": {
          "should": [
            {
              "multi_match": {
                "query": "사과",
                "fields": [
                  "product_name^2",
                  "description"
                ]
              }
            }
          ],
          "minimum_should_match": "0"
        }
      },
      "script": {
        "lang": "painless",
        "params": {
          "query_vector": [0.11, 0.22, 0.33],
          "min_score_threshold": 0.71,
          "beta": 1.0,
          "category_boost_by_id": {
            "4": 0.2
          }
        },
        "source": "<painless script>"
      }
    }
  },
  "sort": [
    {
      "_score": {
        "order": "desc"
      }
    },
    {
      "id": {
        "order": "asc"
      }
    }
  ],
  "track_scores": true,
  "from": 0,
  "size": 20
}
```

```json
##/* <painless script> */##
        
double vectorScore = (cosineSimilarity(params.query_vector, 'product_vector') + 1.0) / 2.0;
double lexicalScore = Math.min(_score, 5.0) / 5.0;
double base = 0.9 * vectorScore + 0.1 * lexicalScore;
if (base < params.min_score_threshold) return 0.0;
double categoryBoost = 0.0;
if (doc['categoryId'].size() != 0) {
  String categoryKey = String.valueOf(doc['categoryId'].value);
  def rawBoost = params.category_boost_by_id.get(categoryKey);
  if (rawBoost != null) {
    categoryBoost = ((Number) rawBoost).doubleValue();
  }
}
double finalScore = base * (1.0 + params.beta * categoryBoost);
return finalScore;
```

### 2-0. painless language 란?
- "lang": "painless"
- 과거에는 expression, mustache(템플릿), 일부 플러그인 기반 언어가 있었지만, 현재는 painless가 표준
- 특히 script_score를 써야 하는 경우에는 painless를 써야 함

### 2-1. 쿼리 연산 순서

#### 1) 전체 구조 관계
```text
query
 └─ script_score
     ├─ query        (기본 점수 계산)
     └─ script
         └─ source   (실제 점수 계산 코드)
```

#### 2) 실행 흐름 (위 -> 아래 순서)

1. 최상위 `query`
- Elasticsearch가 검색을 시작하는 지점

2. `script_score`
- 기본 점수를 계산한 뒤 스크립트로 최종 점수를 다시 계산하겠다는 의미

3. `script_score` 내부 `query`
- 먼저 문서를 찾고 기본 `_score`를 계산
- 예: `multi_match` -> [BM25](./01.embedding-model.md#기존-검색-엔진과-차이) 점수

4. `script`
- 위에서 계산된 `_score`, `doc` 필드 값, `params` 값을 사용해 점수를 재계산

5. `source`
- 실제 painless 코드
- 여기서 `return`한 값이 최종 점수

#### 3) 한 줄 요약

기본 점수 계산 -> 스크립트로 재계산 -> `return` 값이 최종 `_score`

### 2-2. 기본 점수(base)

- `vectorScore = (cosineSimilarity(params.query_vector, 'product_vector') + 1.0) / 2.0`
- `lexicalScore = Math.min(_score, 5.0) / 5.0`
- `base = 0.9 * vectorScore + 0.1 * lexicalScore`

의미:
- 벡터 유사도 90%, 텍스트 매칭 10% 반영
- 텍스트 점수는 `_score`를 0~1 범위로 축소해 과도한 영향 방지

### 2-3. 컷오프(부스팅 전)
- `if (base < min_score_threshold) return 0.0`
- min_score_threshold 보다 작은 문서(검색 결과)를 버림

의미:
- 관련도가 낮은 문서는 카테고리 부스팅 이전에 제외
- "낮은 문서가 부스팅으로 살아나는" 현상 방지

### 2-4. 카테고리 부스팅 적용

- `finalScore = base * (1.0 + beta * categoryBoost)`

파라미터:
- `categoryBoost`: 카테고리 부스팅 데이터로 관리되는 카테고리 가중치 (예: 0.2)
- `beta`: 가중치 영향도 계수 (기본 1.0)
  - beta 계수는 쇼핑몰의 인기도 점수 또는 유사도 점수 특성에 따라 튜닝이 필요
  - beta 계수로 인해 카테고리 부스팅 점수 전체를 조정하지 않고, beta 계수만으로 영향도를 조정 가능

해석:
- `beta = 0` -> 카테고리 부스팅 영향 0
- `beta = 1` -> 룰값 그대로 반영
- `beta > 1` -> 카테고리 부스팅 영향 확대
- `beta < 1` -> 카테고리 부스팅 영향 축소

### 2-5. 최종 점수 반영

- 스크립트의 `return finalScore` 값이 Elasticsearch 문서 `_score`가 된다.
- 변수명(`finalScore`)은 중요하지 않고, `return` 값이 최종 점수다.

## 3) 정렬 규칙

`CATEGORY_BOOSTING_DESC` 정렬은 아래 순서를 사용한다.

1. `_score desc`
2. `id asc` (동점 tie-breaker)

## 4) 현재 운영 파라미터

### `min_score_threshold`
- 키: `ai-search.min-score-threshold`
- 현재 기본값: `${AI_SEARCH_MIN_SCORE:0.71}`

### `beta`
- 클래스: `CategoryBoostBetaTuner`
- 기본값: `DEFAULT_BETA = 1.0`

## 5) 처리 순서(공식 관점)

1. query/sort 정규화
2. 부스팅 적용 대상 여부 결정
3. `vectorScore`, `lexicalScore`, `base` 계산
4. `base < min_score_threshold`면 0점 처리
5. 대상 문서에 `categoryBoost` 적용
6. `finalScore` 반환
7. `_score desc, id asc` 정렬

## 6) 빠른 체크포인트

- `beta=0`이면 부스팅 결과가 `RELEVANCE_DESC`와 동일해야 한다.
- `min_score_threshold`를 올리면 결과 수는 줄고 정밀도는 높아질 가능성이 크다.
- `categoryBoost`가 커질수록 카테고리 우선순위가 강해진다.

# 08. 사용자 정의 사전 처리 가이드 (파일 경로 방식)

## 0. 목표
- 기존 색인 구조를 크게 흔들지 않고 `user_dict_ko.txt`를 Elasticsearch Nori tokenizer에 반영한다.
- 운영 절차는 단순하게 유지한다.
- 코드 변경은 SRP/OCP/DIP를 지키는 범위로 최소화한다.

## 1. 현재 상태 요약
- 사용자 사전 파일은 이미 존재한다.
  - `src/main/resources/es/dictionary/user_dict_ko.txt`
- 인덱스 롤아웃은 이미 구현되어 있다.
  - `src/main/java/com/example/aisearch/service/indexing/orchestration/IndexRolloutService.java`
- 아직 미구현:
  - `index-mapping.json`에 `user_dictionary` 연결
  - ECK YAML에 user-dict ConfigMap/Volume 마운트

## 2. 채택 방식
`nori_tokenizer.user_dictionary`에 ES 컨테이너 내부 파일 경로를 지정한다.

예:
```json
"tokenizer": {
  "ko_nori_userdict_tokenizer": {
    "type": "nori_tokenizer",
    "decompound_mode": "mixed",
    "user_dictionary": "analysis/user_dict_ko.txt"
  }
}
```

핵심 이유:
- 사전이 커져도 안정적
- 사전 파일을 운영에서 독립적으로 관리 가능
- analyzer 설정과 사전 원본 파일의 책임 분리가 명확함

## 3. 최소 변경 작업 순서 (권장)
1. `user_dict_ko.txt` 수정
2. ConfigMap 갱신
3. ECK Elasticsearch에 volume/volumeMount로 사전 파일 마운트
4. `index-mapping.json` tokenizer를 `ko_nori_userdict_tokenizer`로 전환
5. 인덱스 롤아웃 실행(신규 인덱스 생성 + 재색인 + alias 전환)
6. 검색 검증

중요:
- 사용자 사전은 tokenizer 규칙이므로 변경 시 재색인이 필요하다.

## 4. 파일별 작업 가이드

### 4.1 사전 원본
- 파일: `src/main/resources/es/dictionary/user_dict_ko.txt`
- 책임: 도메인 용어 사전 원본 관리
- 규칙: 한 줄 1개 용어(주석 허용)

### 4.2 ES 매핑 템플릿
- 파일: `src/main/resources/es/index-mapping.json`
- 변경:
  - `analysis.tokenizer.ko_nori_userdict_tokenizer` 추가
  - `ko_mall_analyzer`, `ko_mall_search_analyzer`의 tokenizer를 위 이름으로 변경

예시:
```json
{
  "settings": {
    "analysis": {
      "tokenizer": {
        "ko_nori_userdict_tokenizer": {
          "type": "nori_tokenizer",
          "decompound_mode": "mixed",
          "user_dictionary": "analysis/user_dict_ko.txt"
        }
      },
      "analyzer": {
        "ko_mall_analyzer": {
          "type": "custom",
          "tokenizer": "ko_nori_userdict_tokenizer",
          "filter": ["lowercase", "ko_pos_filter"]
        },
        "ko_mall_search_analyzer": {
          "type": "custom",
          "tokenizer": "ko_nori_userdict_tokenizer",
          "filter": ["lowercase", "ko_synonym_filter", "ko_pos_filter"]
        }
      }
    }
  }
}
```

### 4.3 ECK 배포 YAML
- 파일:
  - `sh_bin/es-cluster.yaml`
  - `sh_bin/es-cluster-custom-image.yaml`
- 변경:
  - `volumes`에 ConfigMap 추가
  - `volumeMounts`에 `/usr/share/elasticsearch/config/analysis/user_dict_ko.txt` 추가

예시(ECK spec 일부):
```yaml
spec:
  nodeSets:
    - name: default
      podTemplate:
        spec:
          containers:
            - name: elasticsearch
              volumeMounts:
                - name: user-dict
                  mountPath: /usr/share/elasticsearch/config/analysis/user_dict_ko.txt
                  subPath: user_dict_ko.txt
          volumes:
            - name: user-dict
              configMap:
                name: es-user-dict
```

주의:
- `configMap.name`은 `00_6_apply_user_dictionary_configmap.sh`의 기본값 `es-user-dict`와 맞춰야 한다.
- `subPath`(`user_dict_ko.txt`)와 ConfigMap key가 일치해야 한다.

### 4.4 ConfigMap 반영
예시:
```bash
kubectl create configmap es-user-dict \
  -n ai-search \
  --from-file=user_dict_ko.txt=src/main/resources/es/dictionary/user_dict_ko.txt \
  --dry-run=client -o yaml | kubectl apply -f -
```

프로젝트 스크립트:
```bash
./sh_bin/00_6_apply_user_dictionary_configmap.sh
```

환경별 오버라이드 예:
```bash
NAMESPACE=ai-search CONFIGMAP_NAME=es-user-dict \
DICT_FILE_PATH=src/main/resources/es/dictionary/user_dict_ko.txt \
./sh_bin/00_6_apply_user_dictionary_configmap.sh
```

## 4.5 인덱스 롤아웃 실행 명령
색인만 실행 후 종료:
```bash
./gradlew bootRun \
  --args='--spring.profiles.active=indexing' \
  -Djavax.net.ssl.trustStore=/Users/justinpark/.ai-cert/djl-truststore.p12 \
  -Djavax.net.ssl.trustStorePassword=changeit
```

색인 + 웹 동시 실행:
```bash
./gradlew bootRun \
  --args='--spring.profiles.active=indexing-web' \
  -Djavax.net.ssl.trustStore=/Users/justinpark/.ai-cert/djl-truststore.p12 \
  -Djavax.net.ssl.trustStorePassword=changeit
```

## 5. OOP 원칙 적용 포인트

### 5.1 SRP
- 사전 파일 관리 책임: `user_dict_ko.txt`
- analyzer/매핑 책임: `index-mapping.json`
- 인덱스 교체 책임: `IndexRolloutService`
- 검색 API 책임: `SearchController`/검색 서비스 (변경하지 않음)

### 5.2 OCP
- 향후 사전 소스를 파일 외로 확장(DB/UI)해도 검색 API 시그니처는 유지한다.
- analyzer 변경은 인덱스 lifecycle 계층에서 흡수한다.

### 5.3 DIP
- 상위 정책(롤아웃 오케스트레이션)은 하위 구현(사전 파일 저장 방식)에 직접 의존하지 않게 유지한다.
- 구체 파일 파싱 로직은 필요 시 별도 컴포넌트로 분리하고, 롤아웃은 인터페이스(추상화)만 참조한다.

현재 코드 기준 변경 권장 범위:
- 변경 권장:
  - `src/main/resources/es/index-mapping.json`
  - `sh_bin/es-cluster.yaml`
  - `sh_bin/es-cluster-custom-image.yaml`
  - `src/main/resources/es/dictionary/user_dict_ko.txt`
- 변경 지양:
  - `SearchController`, `VectorSearchService` 등 검색 API 계층
  - `IndexRolloutService`의 롤아웃 순서 로직

## 6. 운영 절차 (단순 버전)
1. 사전 수정
2. ConfigMap 갱신 (`./sh_bin/00_6_apply_user_dictionary_configmap.sh`)
3. (필요 시) ES Pod 롤링 재시작
4. 인덱스 롤아웃 실행
5. 대표 쿼리 검증

대표 검증 쿼리:
- `얇은피`
- `얄피`
- `교자`
- `떡국`

### 6.1 분석기(_analyze) 검증 예시
`얇은피`가 단일 토큰으로 유지되는지 확인:
```bash
curl -u elastic:${AI_SEARCH_ES_PASSWORD:-password} \
  -X POST "http://localhost:9200/food-products-read/_analyze" \
  -H "Content-Type: application/json" \
  -d '{
    "analyzer": "ko_mall_search_analyzer",
    "text": "얇은피 만두"
  }'
```

판정 기준:
- `얇은피` 토큰이 분해되지 않고 기대 형태로 유지되는지 확인

### 6.2 검색 검증 판정 기준
- `q=얇은피`, `q=얄피` 검색 시 만두 관련 상품이 포함되어야 한다.
- 기존 기능 회귀가 없어야 한다.
  - 가격 필터, 카테고리 필터, 정렬, 페이징 정상 동작

## 7. 장애 대응/롤백
1. 신규 인덱스 검증 실패 시 alias 전환을 수행하지 않는다.
2. 이미 alias 전환 후 문제 발생 시 즉시 직전 안정 인덱스로 복구한다.
3. 문제 원인(사전 용어/매핑/마운트) 수정 후 신규 인덱스로 재롤아웃한다.

alias 롤백 예시:
```bash
curl -u elastic:${AI_SEARCH_ES_PASSWORD:-password} -X POST "http://localhost:9200/_aliases" \
  -H "Content-Type: application/json" \
  -d '{
    "actions": [
      { "remove": { "index": "food-products-v20260219150000", "alias": "food-products-read" } },
      { "add":    { "index": "food-products-v20260219143000", "alias": "food-products-read" } }
    ]
  }'
```

## 8. 체크리스트
- [ ] `index-mapping.json`에서 user dictionary tokenizer가 적용되었는가
- [ ] ECK YAML에 volume/volumeMount가 반영되었는가
- [ ] ConfigMap(`es-user-dict`)과 mount/subPath key가 일치하는가
- [ ] 신규 인덱스 생성/재색인/alias 전환이 완료되었는가
- [ ] `_analyze` 결과가 기대 토큰 형태를 만족하는가
- [ ] 검색 회귀(필터/정렬/페이징) 없는가

## 9. 구축 완료 후 단어 변경/적용 방법
초기 구축(매핑 반영 + YAML 마운트 반영)이 끝난 이후에는 아래 순서로 반복 운영한다.

1. `src/main/resources/es/dictionary/user_dict_ko.txt` 수정
2. ConfigMap 갱신
```bash
./sh_bin/00_6_apply_user_dictionary_configmap.sh
```
3. (운영 정책에 따라) ES Pod 롤링 재시작
```bash
kubectl rollout restart statefulset/ai-search-es-es-default -n ai-search
kubectl rollout status statefulset/ai-search-es-es-default -n ai-search
```
4. 인덱스 롤아웃 실행(재색인 + alias 전환)
```bash
./gradlew bootRun \
  --args='--spring.profiles.active=indexing' \
  -Djavax.net.ssl.trustStore=/Users/justinpark/.ai-cert/djl-truststore.p12 \
  -Djavax.net.ssl.trustStorePassword=changeit
```
5. `_analyze` + 검색 쿼리로 검증
   - `_analyze`에서 변경 단어 토큰화 결과 확인
   - `q=얇은피`, `q=얄피` 등 대표 검색 검증

운영 포인트:
- 사용자 사전 변경은 tokenizer 규칙 변경이므로 항상 재색인이 필요하다.
- 매핑 구조를 다시 바꾸는 작업은 필요 없고, "사전 파일 갱신 -> 롤아웃"만 반복하면 된다.

## 10. 결론
- 이 프로젝트에서는 **파일 경로 방식(`user_dictionary`)**이 가장 단순하고 유지보수성이 높다.
- 구현 포인트는 매핑 + 마운트 + 롤아웃 3가지이며, 검색 API 계층은 건드리지 않는 것이 원칙이다.

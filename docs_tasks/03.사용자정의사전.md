# 08. 사용자 정의 사전 처리

## 목적
- Nori 형태소 분석에서 쇼핑몰 도메인 용어를 원하는 단위로 토큰화한다.
- 예: `얇은피`, `얄피`를 분리되지 않는 단일 토큰으로 유지해 검색 품질을 안정화한다.
- 동의어 처리(07)와 함께 적용해 "형태소 분해 + 의미 확장"을 동시에 안정적으로 동작시킨다.

## 적용 전제 (버전/클러스터)
- Elasticsearch `8.x` + `analysis-nori` 플러그인 설치가 완료되어 있어야 한다.
- 클러스터 상태는 `yellow/green` 권장.
- 현재 프로젝트는 Nori 기반 analyzer를 사용하므로, 사전 변경은 analyzer/매핑과 함께 관리한다.

## 구현 가이드 (심플 + 유지보수 중심)
- 사전 원본 파일은 단일 책임으로 관리한다.
  - 파일 관리 책임: dictionary 파일
  - 인덱스 설정 책임: mapping/analyzer 설정
  - 인덱스 재생성 책임: IndexManagementService
- 확장 포인트 최소화:
  - "사전 소스 교체(파일 -> DB/관리자 UI)" 가능성을 고려해 소스 로딩을 분리하되, 초기 구현은 파일 기반으로 단순 유지
- 기존 검색 서비스 영향 최소화:
  - SearchController/SearchService의 검색 API 시그니처를 바꾸지 않는다.
  - Analyzer/Index lifecycle 계층에서만 변경한다.
- OOP 원칙:
  - SRP: 사전 로딩, 인덱스 생성, 검색 요청 처리를 분리
  - OCP: 사전 소스 추가 시 기존 검색 로직 수정 없이 구현체 추가로 확장 가능하게 구성

## 핵심 원칙
- 사용자 정의 사전(`user_dict_ko.txt`)은 형태소 단위 제어를 위한 원본(Source of Truth)이다.
- 사용자 사전 변경은 tokenizer 규칙을 바꾸므로 **재색인 필요**가 기본 원칙이다.
- 운영 순서는 `사전 수정 -> 신규 인덱스 생성 -> 재색인 -> 검색 검증`으로 고정한다.

## 1. 파일 준비
### 1.1 운영 사용자 사전 파일
- 위치: `src/main/resources/es/dictionary/user_dict_ko.txt`

예시:
```text
얇은피
얄피
```

### 1.2 동의어와의 관계
- 사용자 사전은 "토큰화 품질" 담당
- 동의어 사전은 "의미 확장" 담당
- 두 기능을 함께 쓸 때, 먼저 사용자 사전으로 토큰화 안정성을 확보한 뒤 동의어 확장을 적용한다.

## 2. Elasticsearch 적용 방식
### 2.1 tokenizer에 사용자 사전 연결
- `nori_tokenizer`에 `user_dictionary`(파일 경로) 또는 `user_dictionary_rules`(inline) 지정

예시(settings):
```json
{
  "analysis": {
    "tokenizer": {
      "ko_nori_userdict_tokenizer": {
        "type": "nori_tokenizer",
        "user_dictionary": "analysis/user_dict_ko.txt",
        "decompound_mode": "mixed"
      }
    },
    "analyzer": {
      "ko_mall_analyzer": {
        "type": "custom",
        "tokenizer": "ko_nori_userdict_tokenizer",
        "filter": ["lowercase", "ko_pos_filter"]
      }
    }
  }
}
```

### 2.1.1 실제 수정 대상 파일 (프로젝트 기준)
- 인덱스 analyzer/매핑 템플릿: `src/main/resources/es/index-mapping.json`
- 사용자 사전 원본 파일: `src/main/resources/es/dictionary/user_dict_ko.txt`
- 색인 생성 진입점(재생성): `src/main/java/com/example/aisearch/service/indexing/bootstrap/IndexManagementService.java`

수정 체크:
1. `index-mapping.json`에서 tokenizer/analyzer가 Nori 사용자 사전을 참조하도록 반영
2. `product_name`, `description`가 해당 analyzer를 사용하도록 매핑 확인
3. 인덱스 재생성 후 재색인으로 기존 문서 토큰을 갱신

### 2.2 필드 매핑 연결
- 대상 필드: `product_name`, `description`
- 색인 analyzer/검색 analyzer에 사용자 사전 tokenizer가 반영된 analyzer를 사용한다.

### 2.3 배포 방식
- ECK 기준 2가지:
1. ConfigMap/Volume 마운트
2. 커스텀 이미지 내장

이 문서는 **ConfigMap/Volume 마운트 방식**을 기본으로 한다.
- 사용자 사전 변경 시 이미지 재빌드/재배포 없이 파일만 갱신 가능
- 단, 사용자 사전은 tokenizer 규칙이므로 최종 반영을 위해 재색인은 필요

### 2.4 ES 내부 파일 경로 주의
- `src/main/resources/...` 경로는 **애플리케이션 리소스** 경로다.
- `user_dictionary` 설정값은 **Elasticsearch 컨테이너 내부 경로** 기준이어야 한다.
- 예시: `analysis/user_dict_ko.txt`
- 따라서 ConfigMap을 해당 경로로 마운트해야 한다.

예시(ConfigMap):
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: es-user-dict
  namespace: ai-search
data:
  user_dict_ko.txt: |
    얇은피
    얄피
```

예시(ECK Elasticsearch spec 일부):
```yaml
spec:
  nodeSets:
    - name: default
      podTemplate:
        spec:
          containers:
            - name: elasticsearch
              volumeMounts:
                - name: user-dict
                  mountPath: /usr/share/elasticsearch/config/analysis/user_dict_ko.txt
                  subPath: user_dict_ko.txt
          volumes:
            - name: user-dict
              configMap:
                name: es-user-dict
```

## 2.5 sh_bin 실행 순서 (프로젝트 기준)
### 2.5.1 초기 1회 (Nori 플러그인 준비)
> Nori 플러그인이 이미 준비된 환경이면 이 단계는 생략 가능

1. `sh_bin/00_3_build_elasticsearch_nori_image.sh`
2. `sh_bin/00_4_push_elasticsearch_nori_image.sh` (원격 레지스트리 사용 시)
3. `sh_bin/00_5_start_elasticsearch_cluster_custom_image.sh`
4. `sh_bin/00_9_check_elasticsearch_nori_plugin.sh`
5. `sh_bin/01_check_elasticsearch_status.sh`

### 2.5.2 사용자 사전 변경 시 (반복 운영)
이미지 빌드는 하지 않고 ConfigMap만 갱신한다.

1. `user_dict_ko.txt` 수정
2. ConfigMap 반영 (`kubectl apply -f <configmap.yaml>`)
3. 필요 시 ES Pod 롤링 재시작(운영 정책에 따라)
4. 신규 인덱스 생성 + 재색인
5. 검색 검증 + alias 전환

참고:
- 이 반복 운영 단계에서는 `00_3~00_5` 재실행이 기본적으로 필요 없다.
- 핵심은 "파일 갱신 + 재색인"이다.

## 2.6 ConfigMap 반영 명령 예시
```bash
# 파일 기반으로 ConfigMap 업데이트
kubectl create configmap es-user-dict \
  -n ai-search \
  --from-file=user_dict_ko.txt=src/main/resources/es/dictionary/user_dict_ko.txt \
  --dry-run=client -o yaml | kubectl apply -f -

# 필요 시 롤링 재시작 (운영 정책에 따라 선택)
kubectl rollout restart statefulset/ai-search-es-es-default -n ai-search
kubectl rollout status statefulset/ai-search-es-es-default -n ai-search
```

참고:
- 로컬 Docker Desktop만 쓰면 초기 1회 단계에서 `00_4`는 스킵 가능
- 기존 클러스터를 초기화해야 하면 `00_1` -> `00_2`를 먼저 수행

## 3. 재색인 전략 (필수)
- 사용자 사전은 토크나이저 규칙이므로 `reload_search_analyzers`만으로 기존 문서 토큰을 맞출 수 없다.
- 권장 순서:
1. 신규 인덱스 생성 (`v2`)
2. 전체 재색인
3. 검색/품질 검증
4. alias 전환
5. 구 인덱스 정리

### 3.1 alias 전환 예시 (curl)
```bash
# 예시: food-products-read alias를 v2로 전환
curl -u elastic:${PASSWORD} -X POST "http://localhost:9200/_aliases" \
  -H "Content-Type: application/json" \
  -d '{
    "actions": [
      { "remove": { "index": "food-products-v1", "alias": "food-products-read" } },
      { "add":    { "index": "food-products-v2", "alias": "food-products-read" } }
    ]
  }'
```

## 4. 기존 로직 영향 최소화 체크리스트
- SearchController API 변경 없이 동작하는가
- SearchRequest/정렬/페이징 로직을 건드리지 않았는가
- 동의어 리로드 API와 사용자 사전 변경 절차가 충돌하지 않는가
- IndexManagementService/IndexSchemaBuilder 계층에서만 analyzer 변경이 반영되는가

## 5. 테스트 케이스
### 5.1 형태소 분석 단위 테스트 (`_analyze`)
- `얇은피`, `얄피` 입력 시 단일 토큰 유지 여부 검증
- 기대:
  - 사전 미적용: 분리 토큰 가능
  - 사전 적용: 사용자 사전 의도 토큰 유지

### 5.2 통합 테스트 (검색)
- 시나리오:
1. 사전 적용 인덱스 재생성 + 재색인
2. `q=얄피`, `q=얇은피` 검색
3. 만두 관련 상품 노출 여부 확인

검증 포인트:
- 결과가 비어있지 않은지
- `q=얄피`/`q=얇은피`에서 만두 관련 상품(`생만두` 등)이 포함되는지
- 동의어 처리(07)와 함께 동작할 때 회귀가 없는지

### 5.3 회귀 테스트 (동의어와 조합)
- 절차:
1. 사용자 사전 적용 인덱스 기준으로 재색인
2. `reload-synonyms` API로 동의어 반영
3. `q=교자`, `q=얄피`, `q=떡국` 검색 검증

검증 포인트:
- 사용자 사전 + 동의어 조합에서 기대 결과가 유지되는지
- 기존 가격/카테고리/정렬/페이징 기능이 영향받지 않는지

### 5.4 자동화 테스트 연결 (프로젝트 기준)
- 통합 검색 회귀:
  - `src/test/java/com/example/aisearch/VectorSearchIntegrationTest.java`
  - `src/test/java/com/example/aisearch/SynonymsRestClientIntegrationTest.java`
- API 호출 검증:
  - `src/test/java/com/example/aisearch/SearchControllerRestClientTest.java`

실행 예시:
```bash
./gradlew test --tests "*VectorSearchIntegrationTest"
./gradlew test --tests "*SynonymsRestClientIntegrationTest"
./gradlew test --tests "*SearchControllerRestClientTest"
```

## 6. 운영 절차
1. `user_dict_ko.txt` 수정
2. ConfigMap 반영 (`kubectl apply`)
3. 필요 시 ES Pod 롤링 재시작
4. 신규 인덱스 생성 + 재색인
5. 동의어 규칙이 필요한 경우 `reload-synonyms` API 호출
6. 대표 키워드 검색으로 품질 확인
7. alias 전환 및 모니터링

### 6.1 롤백 절차
1. 문제가 발생한 신규 인덱스 사용 중지
2. alias를 직전 안정 인덱스로 즉시 복구
3. 사용자 사전 변경분 원복 후 원인 분석
4. 수정 완료 후 신규 인덱스로 재검증/재전환

## 7. 주의사항
- 사용자 사전 변경은 동의어와 달리 "재색인 없이 즉시 반영"이 어렵다.
- analyzer 구성(특히 필터 순서)이 잘못되면 샤드 할당 실패/검색 500이 발생할 수 있다.
- 대규모 운영에서는 인덱스 버저닝 + alias 전환을 기본 전략으로 사용한다.
- **볼륨 마운트 방식의 장점:** 사용자 사전 변경 시 이미지 재빌드가 필요 없다.

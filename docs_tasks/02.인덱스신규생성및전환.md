# 02. 인덱스 신규 생성 및 전환

## 목적
- 사용자 정의 사전 적용 전에, 기존 인덱스를 안전하게 교체할 수 있는 운영 절차를 정리한다.
- 방식: **새 인덱스 생성 -> 원천 데이터 색인 -> alias 전환 -> 구 인덱스 삭제**

## 전제
- 애플리케이션은 alias를 통해 검색 인덱스를 바라본다.
- 검색 서비스는 **항상 alias만 바라보도록 고정**한다. (물리 인덱스명 직접 참조 금지)
- 설정 분리:
  - `ai-search.index-name`: 버전 인덱스 베이스명 (예: `food-products`)
  - `ai-search.read-alias`: 검색용 alias (예: `food-products-read`)
- 인덱스명 규칙은 `-v{yyyyMMddHHmmss}` 형식을 사용한다.
  - 예: `food-products-v20260213103045`
- 예시:
  - 읽기 alias: `food-products-read`
  - 기존 인덱스: `food-products-v20260212120000`
  - 신규 인덱스: `food-products-v20260213103045`

## 전제 1.1 인덱스명 생성 규칙 관리
- 생성 주체: **Java 색인 로직**
- 외부 파라미터(스크립트 인자/수동 입력)로 인덱스명을 받지 않는다.
- 포맷: `<base-index>-v{yyyyMMddHHmmss}`
  - 예: `food-products-v20260213103045`
- 시간 기준: 애플리케이션 표준 타임존으로 고정
  - 권장: KST(`Asia/Seoul`) 또는 UTC 중 하나로 통일
- 기록:
  - 실행 로그에 `OLD_INDEX`, `NEW_INDEX`, 실행시각을 남긴다.
- 충돌 방지:
  - 초 단위 충돌 가능성이 있는 환경이면 suffix 전략을 추가할 수 있다.
  - 예: `food-products-v20260213103045-r42`

예시(Java):
```java
DateTimeFormatter fmt = DateTimeFormatter.ofPattern("yyyyMMddHHmmss");
String version = LocalDateTime.now(ZoneId.of("Asia/Seoul")).format(fmt);
String newIndex = baseIndex + "-v" + version;
```

## 전제 1.2 Read Alias 쉽게 이해하기
- `read alias`는 검색 서비스가 사용하는 고정된 가상 이름이다.
- 검색 애플리케이션은 항상 `food-products-read`로 조회하고, 실제 인덱스는 버전별로 바뀐다.
- 전환 방식:
  1. 신규 버전 인덱스 생성 (`food-products-v...`)
  2. 데이터 색인 완료
  3. `food-products-read -> 신규 인덱스`로 alias 원자 전환
- 효과:
  - 앱 코드/URL 변경 없이 신규 인덱스로 즉시 전환
  - 문제 시 alias만 이전 인덱스로 되돌려 빠른 롤백 가능
  - 인덱스 교체 과정에서 다운타임 최소화

## 1. 신규 인덱스 생성
- Java 로직이 신규 인덱스명을 자동 생성한 뒤, 최신 매핑/분석기 설정으로 인덱스를 생성한다.
- 구현 포인트:
  - `IndexCreator#createVersionedIndex()`에서 인덱스명 생성 + 인덱스 생성까지 책임진다.
  - 오케스트레이션은 `IndexRolloutService#rollOutFromSourceData()`가 담당한다.
  - 반환값으로 `newIndex`를 넘겨 다음 단계에서 사용한다.
- 검증 포인트:
  - 생성 성공 로그에 `NEW_INDEX`가 남아야 한다.
  - 실패 시 예외를 던지고 이후 단계(색인/alias 전환)로 진행하지 않는다.

## 2. 원천 데이터로 신규 인덱스 색인
- 기존 인덱스를 복사하지 않고, `food-products.json` 같은 원천 데이터에서 신규 인덱스로 직접 색인한다.
- 이유:
  - 사전/동의어/분석기 변경 사항이 신규 인덱스에 정확히 반영됨
  - 기존 인덱스의 과거 분석 결과를 그대로 복제하지 않음
  - `IndexingRunner`의 의도(`recreateIndex + reindexData`)와 일치
- 구현 포인트:
  - `ProductIndexingService#reindexData(newIndex)`로 명시적 대상 인덱스를 받아 색인한다.
  - 색인 대상 데이터는 `food-products.json` 등 원천 데이터로 고정한다.
- 검증 포인트:
  - 색인 건수(`indexedCount`)를 반환하고 0보다 큰지 확인한다.
  - 색인 실패 시 alias 전환 단계로 진행하지 않는다.

## 3. alias 전환
- 검색 트래픽을 기존 인덱스에서 신규 인덱스로 원자적으로 전환한다.
- 이 단계가 끝나면 검색 서비스는 자동으로 신규 인덱스를 바라본다. (서비스 재배포 불필요)
- 구현 포인트:
  - `AliasSwitcher#swapReadAlias(oldIndex, newIndex)`로 원자 전환한다.
  - 검색 API는 물리 인덱스명이 아니라 alias만 참조한다.
- 검증 포인트:
  - alias 조회 결과가 `newIndex`를 가리켜야 한다.

## 4. 구 인덱스 삭제
- 전환 후 문제가 없음을 확인한 뒤 기존 인덱스를 삭제한다.
- 구현 포인트:
  - `IndexCleanupService#deleteIndexIfExists(oldIndex)`를 별도 단계로 호출한다.
  - 삭제는 즉시가 아니라 안정화 확인 후 실행한다.

## 5. 롤백 절차
- alias 전환 후 문제 발생 시 즉시 원복한다.
- 구현 포인트:
  - `AliasSwitcher#swapReadAlias(newIndex, oldIndex)`를 통해 즉시 원복한다.
  - 원복 후 `newIndex`는 원인 분석 전까지 삭제하지 않는다.

- 현재 방식(적용 완료):
```java
IndexRolloutResult result = indexRolloutService.rollOutFromSourceData();
```
- 설명:
  - `recreateIndex()`처럼 alias 대상 인덱스를 즉시 삭제/재생성하는 방식은 중단 위험이 있다.
  - 아래 순서의 오케스트레이션으로 운영한다.
    1. `createVersionedIndex()` : `-v{yyyyMMddHHmmss}` 인덱스 생성
    2. `reindexData(newIndex)` : 원천 데이터 색인
    3. `swapReadAlias(oldIndex, newIndex)` : alias 원자 전환
    4. `deleteIndexIfExists(oldIndex)` : 안정화 후 구 인덱스 삭제
- 핵심:
  - 검색은 항상 alias 기준
  - 색인 완료 전까지 기존 인덱스로 서비스 지속
  - 색인 실패 시 alias 미전환으로 안전 보장
- 현재 구현 반영:
  - `IndexRolloutService#rollOutFromSourceData()`가 오케스트레이션을 담당한다.
  - `IndexingRunner`는 `indexRolloutService.rollOutFromSourceData()`만 호출한다.
  - `ProductIndexingService`는 `reindexData(String indexName)`로 대상 인덱스를 명시해서 색인한다.

## 6. 테스트 영향 범위 및 방식 (SearchIntegrationTest)
- 목적:
  - 인덱스 버전 전환 로직이 기존 검색 기능(키워드/벡터/필터/정렬/페이지)에 회귀를 만들지 검증한다.
- 영향 범위:
  - 인덱스 생성/삭제: 신규 버전 인덱스 생성 실패, 매핑/분석기 적용 실패
  - 색인: 원천 데이터 누락, bulk 오류, 문서 수 불일치
  - alias 전환: 읽기 alias가 구 인덱스를 계속 참조하거나 무참조 상태가 되는 문제
  - 검색 품질: 전환 후 결과 수/스코어/정렬/필터 동작 변화
  - 페이지 메타: totalElements, totalPages, page 값 정합성
- 테스트 방식:
  1. `@BeforeEach` 또는 테스트 시작 단계에서 버전 인덱스 생성 + 원천 데이터 색인 수행
  2. 색인 완료 후 alias를 신규 인덱스로 전환
  3. `SearchIntegrationTest`의 기존 검색 시나리오를 alias 기준으로 실행
  4. 결과(assert)에서 검색 결과 + 페이지 메타를 함께 검증
  5. 테스트 종료 시 생성한 테스트 인덱스를 정리
- 권장 검증 항목:
  - 키워드 검색: 예상 상품명이 포함되는지
  - 카테고리 OR 필터: 다중 categoryId 조건이 정확히 반영되는지
  - 가격 범위 필터: min/max 경계값 포함 여부
  - 조합 검색: 키워드 + 카테고리 + 가격 동시 적용
  - 정렬: `RELEVANCE_DESC`, `PRICE_ASC`, `PRICE_DESC` 결과 순서
  - 페이징: 요청 page/size와 응답 메타(totalElements/totalPages/currentPage) 일치
- 실행 예시:
```bash
./gradlew test --tests "*SearchIntegrationTest"
```
- 실패 시 디버깅 우선순위:
  1. alias가 기대 인덱스를 가리키는지 확인
  2. 신규 인덱스 문서 수와 원천 데이터 건수 일치 여부 확인
  3. 매핑/분석기(특히 nori, 동의어/사전) 적용 상태 확인
  4. bulk 인덱싱 에러 로그(`id/type/reason`) 확인

## 체크리스트
- [ ] 신규 인덱스 생성 성공
- [ ] 원천 데이터 색인 문서 수 검증 완료
- [ ] alias 전환 성공
- [ ] 검색 검증 완료
- [ ] 구 인덱스 삭제 또는 롤백 준비 완료

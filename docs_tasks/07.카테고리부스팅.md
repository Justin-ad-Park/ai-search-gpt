# 07. 카테고리 부스팅 구현 업무지시서 (Codex)

## 0. 개발 요구사항 (필수)
1. `SearchSortOption` 에 `CATEGORY_BOOSTING_DESC` 추가
2. 정렬 조건이 `CATEGORY_BOOSTING_DESC` 인 경우에는 본 문서의 카테고리 부스팅 순서로 검색 결과가 노출되도록 변경
3. 검색 키워드의 공백을 `trim`하고 카테고리 부스팅 키워드와 `equals`(완전 일치) 검색인 경우에만 카테고리 부스팅된 점수로 결과 정렬
  카테고리 부스팅 키워드와 검색 키워드가 일치하지 않으면 지정된 차선 정렬 조건(기본값 `RELEVANCE_DESC`) 으로 정렬 처리
4. 기본 코드의 복잡성을 최소화한다(OCP). 기존 검색 코드의 변경 범위는 필요한 최소 수준으로 제한한다.
5. 새로 추가되는 카테고리 부스팅 로직은 SRP를 준수해 별도 책임 단위(룰 로드/매칭, 점수 계산 적용, 정렬 fallback 판단)로 분리 설계한다.
6. 카테고리 부스팅 도입으로 분기문이 과도하게 증가하지 않도록 리팩터링과 필요한 수준의 디자인 패턴을 적용한다.
7. 과도한 추상화/과설계를 지양하고, 확장성·유지보수성·코드 간결성의 균형을 우선한다.

---

## 1. 작업 목표
- `CATEGORY_BOOSTING_DESC` 요청을 안정적으로 지원
- 키워드 일치 시에만 카테고리 부스팅 적용
- 키워드 불일치 시 `RELEVANCE_DESC` fallback
- 기존 정렬/필터/페이징 동작 회귀(regression) 없이 유지

---

## 2. 기존 코드 분석 (반드시 이해 후 작업)
### 2.1 이미 갖춰진 부분
- `SearchRequest`는 생성자에서 `query.trim()`을 수행하고, sort null이면 `RELEVANCE_DESC`를 기본값으로 설정한다.
  - 파일: `src/main/java/com/example/aisearch/model/search/SearchRequest.java`
- 정렬 규칙은 `SearchSortOption` enum으로 중앙 관리된다.
  - 파일: `src/main/java/com/example/aisearch/model/search/SearchSortOption.java`
- 실제 검색 쿼리 조립/실행은 `KnnSearchStrategy`에 집중되어 있다.
  - 파일: `src/main/java/com/example/aisearch/service/search/strategy/KnnSearchStrategy.java`

### 2.2 현재 구조의 리스크
- `KnnSearchStrategy#hybridSearch` 내부에 카테고리 부스팅 분기까지 직접 추가하면 조건문이 빠르게 증가할 수 있다.
- sort fallback 판단, 룰 조회, script params 구성 로직이 한 메서드에 섞이면 SRP 위반 가능성이 높다.
- 향후 키워드 룰 확장 시(예: 키워드 50개+) 전략 코드 수정 빈도가 커져 OCP에 불리하다.

### 2.3 이번 작업의 설계 원칙
- 전략(`KnnSearchStrategy`)은 "검색 실행"만 담당
- 룰 조회/적용 여부 판단은 별도 컴포넌트로 분리
- 분기는 1회 결정 후 실행 경로를 통일(결정 객체 기반)

---

## 3. 카테고리 부스팅 룰 원본 (현재 기준)
파일:
- `src/main/resources/data/category_boosting.json`

현재 샘플 룰:
- `간식` -> `categoryId 1:+0.20`, `2:+0.10`, `8:+0.10`
- `복숭아` -> `categoryId 4:+0.20`
- `사과` -> `categoryId 4:+0.20`
- `생선` -> `categoryId 7:+0.20`
- `오징어` -> `categoryId 7:+0.20`
- `고등어` -> `categoryId 7:+0.20`

주의:
- 이 파일에는 `vectorMin`, `defaultVectorMin`, `priorityOrder`를 두지 않는다.
- 벡터 임계치 기본값은 `application.yml`의 `ai-search.min-score-threshold`에서 관리한다.

---

## 4. 권장 설계 방향 (복잡도 최소화)
### 4.1 핵심 아이디어: 결정 객체(Decision)로 분기 1회화
`KnnSearchStrategy` 시작 시 아래를 한 번만 결정하고, 이후에는 결정값을 사용해 실행한다.

결정 객체 예시:
- `applyCategoryBoost` (boolean)
- `effectiveSortOption` (`CATEGORY_BOOSTING_DESC` 요청이어도 불일치면 `RELEVANCE_DESC`)
- `categoryBoostById` (적용 시에만 값 존재)

효과:
- 전략 코드에서 `if`가 산재하지 않고, 1회 결정 후 공통 실행 가능
- 향후 조건 추가 시 결정 컴포넌트만 수정하면 되어 OCP에 유리

### 4.2 최소 디자인 패턴 적용
과설계 없이 아래 2개만 적용:
1. Policy/Resolver 패턴
- 역할: 요청 + 룰을 받아 "적용 여부/정렬/boost 파라미터"를 계산

2. Value Object(Decision) 패턴
- 역할: 계산 결과를 불변 객체로 전략에 전달

### 4.3 SRP 기준 책임 분리
- `CategoryBoostingRuleSource`: 룰 파일 로드/조회 책임
- `CategoryBoostingPolicyResolver`: trim 키워드 equals 매칭 + fallback sort 결정 책임
- `KnnSearchStrategy`: ES query/script 실행 책임

---

## 5. 구현 방법 (파일별 상세)
### 5.1 `SearchSortOption` 확장
파일:
- `src/main/java/com/example/aisearch/model/search/SearchSortOption.java`

작업:
- enum에 `CATEGORY_BOOSTING_DESC` 추가
- sort 스펙은 `_score desc`, `id asc`

### 5.2 룰 로더/정책 결정 컴포넌트 추가
신규 권장 파일:
- `src/main/java/com/example/aisearch/service/search/boosting/CategoryBoostingRuleSource.java`
- `src/main/java/com/example/aisearch/service/search/boosting/CategoryBoostingPolicyResolver.java`
- `src/main/java/com/example/aisearch/service/search/boosting/CategoryBoostingDecision.java`

작업:
- JSON 로드 후 `keyword -> categoryBoostById` 맵 보관
- 조회는 `equals`만 허용
- `SearchRequest`를 받아 `CategoryBoostingDecision` 생성

`CategoryBoostingDecision` 필수 필드:
- `boolean applyCategoryBoost`
- `SearchSortOption effectiveSortOption`
- `Map<String, Double> categoryBoostById`

### 5.3 `KnnSearchStrategy` 리팩터링
파일:
- `src/main/java/com/example/aisearch/service/search/strategy/KnnSearchStrategy.java`

작업:
- 기존 `hybridSearch`에서 직접 분기하지 말고 `CategoryBoostingDecision` 주입받아 실행
- script params 구성 시:
  - 항상 `query_vector` 주입
  - `applyCategoryBoost=true`일 때만 `category_boost_by_id` 주입
- script source는 2가지 상수로 분리 권장:
  - BASE_SCRIPT (기존)
  - CATEGORY_BOOST_SCRIPT (카테고리 boost 가산)
- 정렬은 `decision.effectiveSortOption().toSortOptions()` 사용

### 5.4 요청/응답 영향
파일:
- `src/main/java/com/example/aisearch/controller/SearchController.java`
- `src/main/java/com/example/aisearch/controller/dto/SearchResponseDto.java`

원칙:
- API 스펙 변경은 최소화
- 응답 `sort`는 기존처럼 요청값 유지(호환성 유지)
- fallback 여부는 내부 동작으로 처리(필요 시 로그 추가)

---

## 6. 상세 동작 규칙 (명세)
### 6.1 부스팅 적용 조건
- `request.sortOption() == CATEGORY_BOOSTING_DESC`
- `request.query() != null` (이미 trim 처리된 값)
- `ruleSource`에서 `request.query()`와 keyword `equals` 일치

### 6.2 fallback 조건
아래 중 하나라도 해당하면 fallback:
- sort가 `CATEGORY_BOOSTING_DESC`가 아님
- query가 null
- keyword 불일치
- category boosting 룰 로딩 실패(파일 없음/파싱 실패)

fallback 결과:
- `effectiveSortOption = RELEVANCE_DESC`
- category boost 미적용
- 룰 로딩 실패 시에도 검색 자체는 실패시키지 않고, 빈 룰로 간주하여 `RELEVANCE_DESC` 동작으로 처리

### 6.3 점수/정렬
- 벡터+lexical 기본 점수식은 유지
- boost 적용 시 `categoryBoostById` 점수만 추가
- 최종 정렬: `_score desc, id asc`

### 6.4 `q`가 없는 경우(null/blank)
- `CATEGORY_BOOSTING_DESC` 요청이어도 `q`가 null/blank면 부스팅 조건을 만족하지 못하므로 `RELEVANCE_DESC`로 처리
- 즉, 기존 `filterOnlySearch` 경로의 기본 동작을 유지

---

## 7. 테스트 계획
### 7.1 단위 테스트
대상 파일 권장:
- `src/test/java/com/example/aisearch/service/search/boosting/CategoryBoostingPolicyResolverTest.java`
- `src/test/java/com/example/aisearch/service/search/boosting/CategoryBoostingRuleSourceTest.java`

필수 케이스:
1. `" 간식 "` -> trim 후 `간식` 일치, apply=true
2. `"간식추천"` -> 불일치, apply=false + effective sort=RELEVANCE
3. `"사과"` -> boost map에 `4:+0.20`
4. `"오징어"` -> boost map에 `7:+0.20`
5. sort가 `PRICE_ASC`면 무조건 apply=false

### 7.2 통합 테스트
기존 파일 확장:
- `src/test/java/com/example/aisearch/VectorSearchIntegrationTest.java`

필수 케이스:
1. `sort=CATEGORY_BOOSTING_DESC`, `q=간식` -> 부스팅 적용 결과 확인
2. `sort=CATEGORY_BOOSTING_DESC`, `q=오징어 튀김` -> `RELEVANCE_DESC`와 동일 순서 확인 (`id` 순서 동일)
3. `sort=PRICE_ASC`, `q=간식` -> 가격 오름차순 회귀 없음

추가 필수 케이스:
4. 기존 정렬 회귀 검증 (`RELEVANCE_DESC`, `PRICE_ASC`, `PRICE_DESC`)  
   - 카테고리 부스팅 도입 전/후 결과가 기대 정렬 규칙을 유지하는지 확인
5. 키워드 일치 시 카테고리 상위 노출 검증  
   - `sort=CATEGORY_BOOSTING_DESC`, `q=사과` -> Top 5 중 `categoryId=4` 문서가 3개 이상
   - `sort=CATEGORY_BOOSTING_DESC`, `q=오징어` -> Top 5 중 `categoryId=7` 문서가 3개 이상
6. `q` null/blank + `sort=CATEGORY_BOOSTING_DESC`  
   - 내부 `RELEVANCE_DESC` 처리 및 기존 filter-only 정렬 동작 유지

---

## 8. 구현 순서 (권장)
1. `SearchSortOption`에 `CATEGORY_BOOSTING_DESC` 추가
2. 룰 로더 + 정책 결정 컴포넌트 작성
3. `KnnSearchStrategy`에 Decision 기반 적용
4. 단위 테스트 작성
5. 통합 테스트 보강 및 회귀 확인

---

## 9. 완료 조건 (Acceptance Criteria)
- [ ] `CATEGORY_BOOSTING_DESC` 요청이 정상 파싱된다.
- [ ] `q.trim()` == 룰 keyword 일치일 때만 category boost가 반영된다.
- [ ] keyword 불일치 시 내부 `RELEVANCE_DESC` fallback 된다.
- [ ] fallback 검증은 동일 `q`에 대해 `CATEGORY_BOOSTING_DESC` 결과와 `RELEVANCE_DESC` 결과의 `id` 순서 동일성으로 확인한다.
- [ ] 기존 정렬(`RELEVANCE_DESC`, `PRICE_ASC`, `PRICE_DESC`) 동작이 유지된다.
- [ ] 키워드 일치 상위 노출 기준은 Top 5 중 기대 카테고리 3개 이상으로 검증한다.
- [ ] `q`가 null/blank이면 `CATEGORY_BOOSTING_DESC` 요청도 `RELEVANCE_DESC`로 처리된다.
- [ ] `category_boosting.json`에 불필요한 설정값(`vectorMin`, `defaultVectorMin`, `priorityOrder`)이 없다.
- [ ] 룰 로딩 실패 시 검색을 실패시키지 않고 빈 룰 + `RELEVANCE_DESC` fallback으로 동작한다.
- [ ] 전략 클래스의 분기 증가가 최소화되고, 룰 판단/적용 여부 판단 책임이 분리되어 있다.

---

## 10. 참고 코드 위치
- `src/main/java/com/example/aisearch/model/search/SearchSortOption.java`
- `src/main/java/com/example/aisearch/model/search/SearchRequest.java`
- `src/main/java/com/example/aisearch/service/search/strategy/KnnSearchStrategy.java`
- `src/main/java/com/example/aisearch/service/search/query/SearchFilterQueryBuilder.java`
- `src/main/java/com/example/aisearch/controller/SearchController.java`
- `src/test/java/com/example/aisearch/model/search/SearchRequestTest.java`
- `src/test/java/com/example/aisearch/VectorSearchIntegrationTest.java`
- `src/main/resources/data/category_boosting.json`
- `src/main/resources/application.yml`

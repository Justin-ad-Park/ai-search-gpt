# 08. 카테고리 부스팅 캐시 적용 구현 업무지시서 (Codex)

## 0. 목적
카테고리 부스팅 룰을 운영 중 변경 가능한 구조로 전환한다.
단일 인스턴스 기준의 수동 reload 의존을 줄이고, 다중 웹서버 환경에서도 일정 시간 내 자동 반영되도록 TTL 캐시를 도입한다.

---

## 1. 개발 요구사항 (필수)
1. 현재 JSON 기반 룰 조회 구조를 ISP/DIP 기반으로 리팩터링한다.
2. 조회 인터페이스와 리로드 인터페이스를 분리한다.
3. 캐시는 TTL(기본 5분) 방식으로 동작해야 한다.
4. 다중 웹서버 환경에서 개별 서버 재시작/수동 호출 없이도 TTL 내 최신 룰이 반영되어야 한다.
5. 캐시 만료 시 전체 룰을 무조건 재조회하지 않고, 버전 체크 후 변경 시에만 전체 룰 재로딩한다.
6. 리로딩 실패 시 기존 캐시를 유지하고 검색 서비스는 계속 동작해야 한다.
7. 기존 검색 로직(`KnnSearchStrategy`, `CategoryBoostingDecider`)의 변경 범위는 최소화한다.

### 1.1 최종 결정사항 (고정)
1. TTL 설정은 `application.yml`로 관리한다.
- 키: `ai-search.category-boost-cache-ttl-seconds`

2. JSON 경로 주입 방식은 생성자 오버로딩으로 처리한다.
- 기본 생성자: 상수 경로 사용
  - `private static final String RULE_FILE_PATH = "classpath:data/category_boosting.json";`
- 보조 생성자: 파일 경로 파라미터를 받아 다른 파일 로딩(테스트/특수 케이스)
- 용어: 이 방식은 메서드 오버로딩이 아니라 **생성자 오버로딩**이다.

3. 패키지 마이그레이션 완료 후 구 패키지는 삭제한다.
- 대상: `src/main/java/com/example/aisearch/service/search/boosting/*`
- 조건: 신규 패키지(`...search.categoryboost`)로 참조가 완전히 이동된 이후

---

## 2. 범위
포함:
- 카테고리 부스팅 룰 조회/리로드 인터페이스 분리
- TTL 캐시(Caffeine) 도입
- 버전 체크 기반 조건부 재로딩
- JSON 기반 구현체 리팩터링
- 단위/통합 테스트 보강

제외:
- DB 실제 연동 구현(이번 단계에서는 인터페이스/구조만 준비)
- 이벤트 기반 무효화(Redis PubSub/Kafka) 구현
- 검색 점수 공식 변경

---

## 3. 패키지 구조 (최소 시작안)
루트 패키지:
- `com.example.aisearch.service.search.categoryboost`

하위 패키지:
1. `...categoryboost.api`
- `CategoryBoostRules`
- `CategoryBoostRulesReloader`

2. `...categoryboost.policy`
- `CategoryBoostingDecider`
- `CategoryBoostingResult`

3. `...categoryboost.store`
- `JsonCategoryBoostRules`

주의:
- 기존 `...service.search.boosting` 패키지는 위 구조로 이동/정리한다.

---

## 4. 인터페이스 설계 (ISP)
### 4.1 조회 인터페이스
```java
public interface CategoryBoostRules {
    Optional<Map<String, Double>> findByKeyword(String keyword);
}
```

### 4.2 리로드 인터페이스
```java
public interface CategoryBoostRulesReloader {
    void reload();
}
```

원칙:
- `CategoryBoostingDecider`는 `CategoryBoostRules`만 의존
- 운영/관리 경로만 `CategoryBoostRulesReloader` 의존

---

## 5. 캐시 전략 (Option 1 채택)
### 5.1 선택 전략
- 로컬 캐시: `Caffeine`
- TTL: 5분 (`expireAfterWrite = 5m`)
- 캐시 단위: 룰 전체 1개 엔트리(권장)

### 5.2 재로딩 방식
1. 캐시 TTL 만료 시 `category_boosting.json`의 `version` 값을 먼저 확인
2. 버전이 동일하면 기존 룰 유지(전체 재로딩 생략)
3. 버전이 다르면 룰 전체를 다시 로딩하고 캐시를 원자적으로 교체
4. `version` 누락/파싱 실패 시 재로딩 실패로 간주하고 기존 캐시 유지

캐시 비교 기준:
- 캐시에는 룰만 저장하지 않고 `version`을 함께 저장한다.
- 비교는 `cachedVersion` vs `newVersion` 문자열 동등성(`equals`)으로 수행한다.

### 5.3 실패 정책
- 버전 조회/룰 로딩 실패 시:
  - 기존 캐시 유지
  - 검색 요청 실패로 전파하지 않음
  - 경고 로그 기록

---

## 6. 데이터 소스 설계 (현재 JSON, 향후 DB)
### 6.1 현재 단계(JSON)
- `JsonCategoryBoostRules`가 룰/버전 제공
- 버전 기준: JSON 내부 `version` 필드(필수)
- 파일 예시:
```json
{
  "version": "2026.02.24.1",
  "rules": [
    {
      "keyword": "사과",
      "categoryBoostById": {
        "4": 0.20
      }
    }
  ]
}
```
- `version` 정책:
  - 문자열 버전 허용 (`2026.02.24.1`, `v12` 등)
  - 이전 버전과 문자열 값이 다르면 변경으로 간주
  - `version`이 비어 있으면 유효하지 않은 룰 파일로 처리

### 6.2 향후 단계(DB)
- 동일 인터페이스 구현체 `DbCategoryBoostRules` 추가
- 버전 기준 예시:
  - `category_boost_rules_meta.version`
  - `updated_at`

전환 원칙:
- 구현체 교체만으로 동작 전환 가능해야 함
- Resolver/Strategy 코드는 수정하지 않는다.

---

## 7. 구현 상세 가이드
### 7.1 `build.gradle`
- Caffeine 의존성 추가
  - `implementation 'com.github.ben-manes.caffeine:caffeine'`

### 7.2 신규/이동 클래스
- `...categoryboost.api.CategoryBoostRules`
- `...categoryboost.api.CategoryBoostRulesReloader`
- `...categoryboost.policy.CategoryBoostingDecider`
- `...categoryboost.policy.CategoryBoostingResult`
- `...categoryboost.store.JsonCategoryBoostRules`
- `...categoryboost.policy.SearchExecutionPlanBuilder` (신규)
- `...categoryboost.policy.SearchExecutionPlan` (신규)
- `...categoryboost.policy.ScoreScriptFactory` (신규)

### 7.3 `JsonCategoryBoostRules` 구현 포인트
- Bean 초기화 시 1회 로드
- `findByKeyword`는 trim+equals 기준 조회
- 내부 캐시 갱신은 원자적 교체
- TTL 만료 시 JSON의 `version` 체크 -> 필요 시만 재로딩
- 로딩 시 `version` + `rules`를 함께 파싱하고, 둘 중 하나라도 유효하지 않으면 로딩 실패 처리
- 캐시 엔트리 구조 예시:
```java
record CategoryBoostCacheEntry(
    String version,
    Map<String, Map<String, Double>> rulesByKeyword
) {}
```
- TTL 만료 시 처리 순서:
  1. 파일에서 `newVersion`만 조회
  2. `cachedVersion.equals(newVersion)`이면 재로딩 생략
  3. 다르면 전체 JSON 파싱 후 새 `CategoryBoostCacheEntry`로 원자 교체
  4. 전체 파싱 실패 시 기존 캐시 유지

### 7.4 Resolver/Strategy 영향
- `CategoryBoostingDecider` 생성자 의존성을 `CategoryBoostRules`로 변경
- `KnnSearchStrategy`는 실행 오케스트레이션 역할만 유지하고, 분기/스크립트 구성은 하위 컴포넌트로 위임

### 7.5 `vectorScoreSearch` 리팩터링 방향 (필수)
목표:
- `vectorScoreSearch`의 스파게티 분기(결정/스크립트 선택/파라미터 조립)를 제거
- 메서드 역할을 "계획 생성 -> 실행" 두 단계로 단순화

권장 구성:
1. `CategoryBoostingDecider`
- 입력: `SearchRequest`
- 출력: `CategoryBoostingResult` (적용 여부, fallback 정렬)

2. `SearchExecutionPlanBuilder`
- 입력: `SearchRequest`, `CategoryBoostingResult`, `queryVector`
- 출력: `SearchExecutionPlan` (effectiveSort, scriptVariant, scriptParams)

3. `ScoreScriptFactory`
- 입력: `scriptVariant`, `scriptParams`
- 출력: 점수 스크립트 `source` + `params`
- 역할 범위: `script_score`의 점수 스크립트 전용
- 주의: 검색 query/filter/sort/pagination 전체를 구성하지 않는다.

4. `KnnSearchStrategy`
- 위 3개 컴포넌트를 조합해 ES 호출만 수행
- 직접 `if (applyBoost)` 분기/문자열 조립을 최소화

네이밍 원칙:
- `PainlessScriptRenderer` 같은 구현 기술 중심 명칭 대신 `ScoreScriptFactory` 사용
- 이유: 역할 중심 네이밍, 구현 기술 변경 내성, 코드 가독성 향상

---

## 8. 운영 관점 요구사항
1. 다중 웹서버 각각 로컬 캐시를 가지되 TTL 내 수렴 가능해야 한다.
2. 관리 API가 없어도 TTL 기반 자동 반영이 가능해야 한다.
3. 필요 시 수동 강제 반영을 위해 `CategoryBoostRulesReloader.reload()` 호출 지점을 열어둔다.
4. 최소 운영 로그:
- 마지막 성공 로드 시각
- 현재 룰 버전
- 최근 로딩 실패 횟수

---

## 9. 테스트 계획
### 9.1 단위 테스트
1. 초기 로딩 성공 시 키워드 조회 성공
2. TTL 미만 구간에서는 재로딩 없이 캐시 조회
3. TTL 이후 버전 동일 시 전체 룰 재로딩 생략
4. TTL 이후 버전 변경 시 룰 재로딩 수행
5. 재로딩 실패 시 기존 캐시 유지
6. `CategoryBoostingDecider`는 불일치 시 `RELEVANCE_DESC` fallback 유지
7. `SearchExecutionPlanBuilder`가 입력 조건별로 올바른 `effectiveSort/scriptVariant/params`를 생성
8. `ScoreScriptFactory`가 variant별 스크립트(source/params)를 정확히 반환
9. JSON `version` 누락/blank/파싱 실패 시 기존 캐시 유지 검증
10. `cachedVersion`과 `newVersion`이 같으면 전체 파싱/교체가 발생하지 않음을 검증

### 9.2 통합 테스트
1. 캐시 적중/만료 시나리오에서 검색 결과 일관성 확인
2. 버전 변경 후 TTL 경과 시 반영 확인
3. 다중 인스턴스 가정 테스트(모의): 서로 다른 캐시 인스턴스가 TTL 내 수렴하는지 확인
4. `CATEGORY_BOOSTING_DESC` 요청에서 키워드 일치/불일치 시 `effectiveSort` 및 결과 순서가 의도대로 동작

### 9.3 반복 테스트를 위한 권장 방식
목표:
- 버전 변경 테스트를 빠르고 반복 가능하게 수행
- 파일 I/O/실시간 대기(`sleep`) 의존도를 줄여 CI 안정성 확보

권장 설계:
1. JSON fixture 2개 준비
- `src/test/resources/data/category_boosting_v1.json`
- `src/test/resources/data/category_boosting_v2.json`
- 두 파일은 동일 구조를 유지하고 `version` 값만 다르게 관리(필요 시 룰 차이 1개만 추가)

2. 읽는 대상 경로를 설정값으로 주입
- `JsonCategoryBoostRules` 기본 경로는 상수 사용:
  - `private static final String RULE_FILE_PATH = "classpath:data/category_boosting.json";`
- 테스트/특수 상황에서만 파일 경로를 파라미터로 받아 다른 파일을 로딩
- 예: 생성자 오버로딩(또는 테스트 전용 팩토리)으로 경로 주입

3. 시간 제어 분리
- `Clock`(또는 동등한 시간 공급자) 주입
- 테스트에서 TTL 경과를 가상 시간으로 제어하여 `sleep` 제거

반복 테스트 핵심 케이스:
- TTL 만료 + 버전 동일 -> 재로딩 미발생
- TTL 만료 + 버전 변경 -> 재로딩 발생
- TTL 만료 + 버전 변경 + 로딩 실패 -> 기존 캐시 유지
- 버전 누락/blank -> 재로딩 실패 + 기존 캐시 유지

권장 흐름 예시:
1. 생성자 오버로딩으로 `v1` 파일 경로를 주입해 로드 후 조회
2. 동일 테스트에서 경로 공급자 값을 `v2` 파일 경로로 변경 + `reload()` 호출
3. 버전 변경 반영 여부 검증

---

## 10. 완료 조건 (Acceptance Criteria)
- [ ] `CategoryBoostRules`/`CategoryBoostRulesReloader` 인터페이스가 도입되었다.
- [ ] `CategoryBoostingDecider`가 조회 인터페이스만 의존한다.
- [ ] Caffeine TTL 캐시(기본 5분)가 적용되었다.
- [ ] TTL 만료 시 `category_boosting.json.version` 체크 후 변경 시에만 전체 재로딩한다.
- [ ] 캐시 엔트리에 `version`과 `rules`가 함께 저장되고, `cachedVersion` 비교 기반으로 재로딩 여부를 결정한다.
- [ ] 로딩 실패 시 기존 캐시 유지 + 검색 지속 동작이 보장된다.
- [ ] 기존 카테고리 부스팅 검색 동작/테스트가 회귀 없이 유지된다.
- [ ] 향후 DB 구현체 추가 시 Resolver/Strategy 수정 없이 교체 가능하다.
- [ ] `vectorScoreSearch`의 분기/스크립트 조립 로직이 `Decider + PlanBuilder + ScoreScriptFactory`로 분리되어 이해 가능성이 개선되었다.

---

## 11. 후속 단계 (이번 작업 범위 밖)
1. `DbCategoryBoostRules` 구현
2. 관리 API (`/api/search/reload-category-boost`) 추가
3. 이벤트 기반 무효화(Redis/Kafka) + TTL 백업 전략 도입

---

## 12. 참고 파일 및 정리 기준
- `src/main/java/com/example/aisearch/service/search/strategy/KnnSearchStrategy.java`
- `src/main/java/com/example/aisearch/service/search/boosting/*` (구 패키지, 마이그레이션 완료 후 삭제 대상)
- `src/main/java/com/example/aisearch/service/search/categoryboost/**` (신규 구조)
- `src/main/resources/data/category_boosting.json`
- `src/test/resources/data/category_boosting_v1.json`
- `src/test/resources/data/category_boosting_v2.json`
- `build.gradle`
- `docs_tasks/07.카테고리부스팅_todo.md`

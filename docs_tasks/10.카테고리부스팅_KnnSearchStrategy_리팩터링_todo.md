# 10. 카테고리부스팅 KnnSearchStrategy 리팩터링 TODO

## 배경
현재 `KnnSearchStrategy`는 아래 책임을 동시에 가진다.

1. 검색 흐름 분기 (query 유무에 따른 vector/filter-only)
2. 하이브리드 점수 스크립트 문자열 구성
3. Elasticsearch SearchRequest 조립
4. script params 주입
5. 검색 결과 매핑/후처리

이 구조는 기능 확장 시 변경 지점이 많아지고 테스트 결합도가 높아진다.

---

## 목표

1. `KnnSearchStrategy`를 오케스트레이션 역할로 축소
2. 점수 스크립트 구성 책임 분리 (`Script Factory`)
3. ES 요청 조립 책임 분리 (`Request Builder`)
4. 결과 매핑 책임 분리 (`Result Mapper`)
5. 기존 동작/랭킹 품질/테스트 호환 유지

---

## 진행 현황

- 완료:
  - `PainlessHybridScoreScriptFactory` 분리
  - `HybridBaseQueryBuilder` 분리
  - `ElasticsearchSearchRequestBuilder` 분리 (hybrid/filter-only 요청 조립 통합)
  - `DefaultSearchResponseMapper` 분리
  - `KnnSearchStrategy` 내부 응답 변환 헬퍼(`toResults`, `stripVector`, `extractTotalHits`) 제거 및 mapper 위임
  - `KnnSearchRequestSerializationTest`가 프로덕션 빌더를 재사용하도록 전환
  - `KnnSearchStrategy`에서 script 문자열 상수 제거 및 빌더 위임

- 미완료:
  - `DefaultSearchResponseMapperTest` 추가
  - 리팩터링 친화적 테스트 구조 정리 마무리

---

## 리팩터링 원칙 (SOLID)

- SRP: 클래스당 1개 핵심 책임
- OCP: 점수식/파라미터 확장은 새 구현 추가로 대응
- DIP: `KnnSearchStrategy`는 구체 구현이 아닌 추상 계약에 의존
- 점진적 적용: 한 번에 큰 구조 변경 없이 단계적으로 이동

---

## 대상 구조 (현재 + 목표)

## 1) `PainlessHybridScoreScriptFactory` (완료)

### 책임
- category boost 적용 여부에 따라 script source/params 규칙 생성

### 패키지
- `com.example.aisearch.service.search.strategy.script`

### 제공 메서드
```java
String selectScriptSource(CategoryBoostingResult decision)
```

---

## 2) `ElasticsearchSearchRequestBuilder` (완료)

### 책임
- vector 검색용 ES `SearchRequest` 조립
- `query/script/sort/paging/min_score` 등 빌드 로직 집중

### 패키지
- `com.example.aisearch.service.search.strategy.request`

### 제공 메서드

```java
public class ElasticsearchSearchRequestBuilder {
    public co.elastic.clients.elasticsearch.core.SearchRequest buildHybridRequest(
        String readAlias,
        Query baseQuery,
        CategoryBoostingResult decision,
        List<Float> queryVector,
        int from,
        int size
    ) { ... }

    public co.elastic.clients.elasticsearch.core.SearchRequest buildFilterOnlyRequest(
        String readAlias,
        Query rootQuery,
        SearchSortOption sortOption,
        int from,
        int size
    ) { ... }
}
```

### 타입명 명확화 원칙
- 앱 요청 모델은 `com.example.aisearch.model.search.SearchRequest`를 `searchRequest`로 명명
- ES 요청 모델은 `co.elastic.clients.elasticsearch.core.SearchRequest`를 `esSearchRequest`로 명명
- 코드/문서에서 `SearchRequest` 단일 이름만 쓰지 않는다.

### 구현
- 의존성: `AiSearchProperties`, `CategoryBoostBetaTuner`, `PainlessHybridScoreScriptFactory`

---

## 3) `HybridBaseQueryBuilder` (완료)

### 책임
- 하이브리드 검색의 베이스 bool 쿼리(lexical should + filter) 생성

### 패키지
- `com.example.aisearch.service.search.query`

### 제공 메서드
```java
Query build(com.example.aisearch.model.search.SearchRequest searchRequest, Optional<Query> filterQuery)
```

---

## 4) `SearchResponseMapper` (완료)

### 책임
- `SearchResponse<Map>` -> `SearchPageResult` 매핑
- `product_vector` 제거 포함

### 패키지
- `com.example.aisearch.service.search.strategy.mapper`

### 제안 클래스(1차)

```java
public class DefaultSearchResponseMapper {
    public SearchPageResult toPageResult(SearchResponse<Map> response, Pageable pageable) { ... }
}
```

### 기본 구현
- `DefaultSearchResponseMapper`

---

## 5) `KnnSearchStrategy` (리팩터링 후)

### 책임
- search 흐름 분기
- 협력 객체 호출 오케스트레이션
- 예외 경계 처리

### 예상 필드

```java
private final ElasticsearchClient client;
private final AiSearchProperties properties;
private final EmbeddingService embeddingService;
private final SearchFilterQueryBuilder filterQueryBuilder;
private final HybridBaseQueryBuilder hybridBaseQueryBuilder;
private final CategoryBoostingDecider categoryBoostingDecider;
private final ElasticsearchSearchRequestBuilder searchRequestBuilder;
private final DefaultSearchResponseMapper searchResponseMapper;
```

---

## 구현 단계 (점진 적용)

## Step 1. Script/Query/Request Builder 분리 (완료)
- `PainlessHybridScoreScriptFactory`, `HybridBaseQueryBuilder`, `ElasticsearchSearchRequestBuilder` 도입
- `KnnSearchStrategy`는 빌더 호출 중심으로 전환
- `KnnSearchRequestSerializationTest`는 프로덕션 빌더 재사용

완료 기준:
- `KnnSearchStrategy`에서 script 문자열 상수 제거
- 요청 조립 중복 제거
- 관련 테스트 통과

## Step 2. Response Mapper 분리 (완료)
- `toResults`, `stripVector`, `extractTotalHits`를 mapper로 이동

완료 기준:
- `KnnSearchStrategy` 내부 매핑 헬퍼 제거
- 결과 JSON/필드 동작 동일

## Step 3. 테스트 구조 정리 (진행 중)
- script 문자열 전체 비교보다 "핵심 파라미터/구조" 검증 중심으로 개편

완료 기준:
- 리팩터링 친화적 테스트로 전환
- 관련 기존 테스트 통과

---

## 테스트 전략 (리팩터링 후 실행 대상)

1. 단위 테스트
- `PainlessHybridScoreScriptFactoryTest`
  - applyCategoryBoost true/false source 분기
  - params 주입 (`query_vector`, `min_score_threshold`, `beta`, `category_boost_by_id`) 검증

- `HybridBaseQueryBuilderTest`
  - should/must/filter/minimumShouldMatch 조합 검증

- `DefaultSearchResponseMapperTest`
  - `product_vector` 제거 검증
  - total hits null-safe 검증

2. 통합/직렬화 테스트
- `KnnSearchRequestSerializationTest`
- `CategoryBoostingTest`
- `SynonymsRestClientIntegrationTest`
- `SearchControllerRestClientTest` (요청/응답 계약 영향 확인)

---

## 위험 요소 및 대응

1. 스크립트 변경으로 점수 분포 변동
- 대응: 점수식 자체는 변경하지 않고 "위치만 이동" 원칙 유지

2. 테스트 대량 수정 리스크
- 대응: Step 단위로 클래스 이동 후 테스트 보강

3. 과도한 추상화
- 대응: 현재처럼 구현 클래스 추출 우선, 인터페이스는 확장 요구 시 도입

---

## 이번 문서 범위 제외

- beta 동적 저장소(DB/원격 설정) 연동
- 쿼리 타입별 score 정책 엔진화
- ANN 후보군 분리 파이프라인 재설계

---

## 예상 산출물

1. 새 패키지/클래스
- `strategy.script.PainlessHybridScoreScriptFactory`
- `query.HybridBaseQueryBuilder`
- `strategy.request.ElasticsearchSearchRequestBuilder`
- `strategy.mapper.DefaultSearchResponseMapper`

2. 변경 클래스
- `KnnSearchStrategy` (오케스트레이션 중심으로 축소)

3. 테스트
- 신규 단위 테스트 2~3개
- 기존 통합/직렬화 테스트 회귀 통과

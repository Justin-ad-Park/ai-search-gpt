# 09. 카테고리부스팅 개선 TODO

## 배경
이번 작업은 벡터 기반 의도 검색을 유지하면서 아래 3가지를 개선하는 것이 목적이다.

1. `minScore(0.74)` 미만 문서가 부스팅으로 노출되지 않게 차단
2. 카테고리 부스팅 영향도 `beta` 튜닝 다이얼 추가
3. 점수 상한 제거로 상위 동점(1.0 몰림) 완화

---

## 합의된 기준 (대화 요약)

- 컷오프 기준값은 기존 `ai-search.min-score-threshold` 하나만 사용한다. (기본 0.74)
- 새로운 cutoff 개념/용어를 추가하지 않는다.
- 부스팅 전에 원점수로 먼저 컷오프를 적용한다.
- Elasticsearch 요청의 `.minScore(properties.minScoreThreshold())`는 유지한다.

---

## 1) cutoff 결과 제거 (0.74 미만 제외)

### 구현
스크립트에서 부스팅 전 원점수(`base`)를 먼저 계산하고,
`properties.minScoreThreshold()`를 script params로 전달받아 임계값으로 사용한다.

```painless
double base = 0.9 * vectorScore + 0.1 * lexicalScore;
if (base < params.min_score_threshold) return 0.0;
```

그 다음에만 카테고리 부스팅 계산을 적용한다.

### 의도
- "원래 점수가 낮은 문서"가 부스팅 때문에 임계값을 넘는 상황을 방지
- 컷오프 기준을 기존 0.74 하나로 일관 유지

### 코드 적용 위치
- `src/main/java/com/example/aisearch/service/search/strategy/KnnSearchStrategy.java`

### 요청 레벨 설정
- 기존 유지:

```java
.minScore(properties.minScoreThreshold()) // 기본 0.74
```

- script params 추가:

```java
.params("min_score_threshold", JsonData.of(properties.minScoreThreshold()))
```

---

## 2) 부스팅 영향도 `beta` 추가

### 구현
카테고리 부스팅 강도를 운영에서 조정할 수 있도록 `beta` 파라미터를 도입한다.

```painless
double finalScore = base * (1.0 + params.beta * categoryBoost);
return finalScore;
```

- `beta = 0`: 카테고리 부스팅 비활성
- `beta = 1`: 룰값 그대로 반영

### beta 관리 클래스 제안 (Class + 상수 기본값 + 테스트 set)
1. 패키지 위치
- `com.example.aisearch.service.search.categoryboost.policy`

2. 클래스명
- `CategoryBoostBetaTuner`

3. 제공 필드/메서드
- `public static final double DEFAULT_BETA = 1.0;`
- `public double getBeta();`
- `public void setBeta(double beta);`
- `public void reset();`

4. 권장 구현
- 내부 상태는 `AtomicReference<Double>`로 관리
- `setBeta`에서 유효 범위 검증 (`beta >= 0.0`)

```java
@Component
public class CategoryBoostBetaTuner {
    public static final double DEFAULT_BETA = 1.0;
    private final AtomicReference<Double> beta = new AtomicReference<>(DEFAULT_BETA);

    public double getBeta() { return beta.get(); }

    public void setBeta(double value) {
        if (value < 0.0) throw new IllegalArgumentException("beta must be >= 0");
        beta.set(value);
    }

    public void reset() { beta.set(DEFAULT_BETA); }
}
```

### 코드 반영
1. `KnnSearchStrategy`
- `CategoryBoostBetaTuner` 주입
- script params에 `min_score_threshold`, `beta` 전달
  - `params("min_score_threshold", JsonData.of(properties.minScoreThreshold()))`
  - `params("beta", JsonData.of(categoryBoostBetaTuner.getBeta()))`

2. 테스트
- 테스트 코드에서 `categoryBoostBetaTuner.setBeta(...)`로 값 변경
- `@AfterEach`에서 `categoryBoostBetaTuner.reset()`으로 복원

---

## 3) 부스팅 상한 제거 (동점 완화)

### 구현
- 기존 `Math.min(1.0, ...)` 제거
- cap 없는 점수 반환으로 상위권 1.0 동점 군집 완화

### 코드 적용 위치
- `src/main/java/com/example/aisearch/service/search/strategy/KnnSearchStrategy.java`

---

## OOP/리팩토링 (적정 수준)

## A. 설정 책임 명확화
`AiSearchProperties`와 beta 튜너의 책임을 분리한다.
- 유지: `minScoreThreshold`
- beta: `CategoryBoostBetaTuner`에서 상수 기본값 + 가변 관리

## B. 스크립트 구성 단일화
스크립트 문자열과 params 주입을 한 메서드로 모아 수정 지점 최소화

## C. 의미 주석 보강
`minScoreThreshold`가 품질 컷오프 기준임을 코드 주석/문서에 명시

---

## 테스트 계획

## 1. 직렬화 테스트 (`KnnSearchRequestSerializationTest`)
- script source에 cutoff 로직(`base < params.min_score_threshold -> 0.0`) 포함 확인
- `min_score_threshold` params 포함 확인
- `beta` params 포함 확인 (`CategoryBoostBetaTuner#getBeta` 반영)
- cap 제거 확인 (`Math.min(1.0, ...)` 없음)
- request `.min_score`가 `properties.minScoreThreshold()`로 직렬화되는지 확인

## 2. 통합 테스트 (`CategoryBoostingTest`)
- 저품질 문서가 부스팅으로 노출되지 않는지 확인
- `categoryBoostBetaTuner.setBeta(0)`에서 카테고리 부스팅 영향 제거 확인
- cap 제거 후 Top N 동점 비율 감소 확인
- 기존 fallback 시나리오 회귀 확인

---

## 구현 순서
1. `KnnSearchStrategy` 스크립트 변경 (부스팅 전 컷오프 + beta 곱산 + cap 제거)
2. `CategoryBoostBetaTuner` 클래스 추가 (상수 기본값 + set/reset)
3. `KnnSearchStrategy`에 `CategoryBoostBetaTuner` 주입 및 script params에 `beta` 전달
4. 테스트 갱신 및 회귀 확인
5. 관련 문서 동기화

---

## 범위 제외 (후속)
- beta/threshold DB 동적 로딩
- 쿼리/카테고리별 beta 차등
- 온라인 A/B 자동화

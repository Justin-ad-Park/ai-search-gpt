아래는 “동작 유지 + 복잡도 감소” 관점에서 덜어낼 후보입니다. 우선순위(효과 대비 리스크) 순으로 정리했습니다.

1. ProductIndexingService의 미사용 의존성 제거
   src/main/java/com/example/aisearch/service/indexing/bootstrap/ingest/ProductIndexingService.java:14
   AiSearchProperties properties 필드/생성자 주입이 실제로 전혀 사용되지 않습니다. 바로 제거 가능한 죽은 의존성입니다.
2. 실제 미사용 설정값 제거 (num-candidates-*)
   src/main/java/com/example/aisearch/config/AiSearchProperties.java:48
   src/main/resources/application.yml:18
   numCandidatesMultiplier, numCandidatesMin가 설정/프로퍼티에는 있는데 코드 사용처가 없습니다(전역 검색 기준). 설정-코드 불일치라 혼선을 유발합니다.
3. VectorSearchService의 테스트 편의 메서드 축소
   src/main/java/com/example/aisearch/service/search/VectorSearchService.java:34
   search(SearchRequest, Pageable), search(String, int)는 프로덕션 경로보다 테스트 편의용 API입니다(주 사용처는 통합테스트). 서비스 API 표면을 줄이려면 searchPage()만 남기고 테스트에서 .results() 사용으로 통일하는 게 단순합니다.
4. KnnSearchStrategy의 불필요한 메서드 1단계 제거
   src/main/java/com/example/aisearch/service/search/strategy/KnnSearchStrategy.java:156
   resolveReadAlias()가 requireReadAlias()를 그대로 호출만 합니다. 한 단계 wrapper 제거로 읽기 난이도 감소.
5. Null 기반 쿼리 빌드 계약 단순화
   src/main/java/com/example/aisearch/service/search/query/SearchFilterQueryBuilder.java:21
   buildFilterQuery()가 null을 반환하고, 호출부가 분기 처리하는 구조라 인지부하가 큽니다. Optional<Query> 또는 항상 Query 반환(예: match_all)로 계약을 단순화하면 분기 수가 줄어듭니다.
6. 임베딩 정규화 컴포넌트 과분리 검토
   src/main/java/com/example/aisearch/service/embedding/model/EmbeddingNormalizer.java:12
   EmbeddingNormalizer는 현재 DjlEmbeddingService 1곳에서만 사용됩니다. 재사용 계획이 없다면 private static 메서드로 접어 파일/빈 수를 줄일 수 있습니다.
7. ES 자동연결 보조 컴포넌트 과분해 축소 가능
   src/main/java/com/example/aisearch/support/connection/parts/PortForwardDecision.java:9
   src/main/java/com/example/aisearch/support/connection/parts/ElasticsearchUrlBuilder.java:8
   src/main/java/com/example/aisearch/support/k8s/ElasticPasswordProvider.java:8
   모두 단일 메서드/단일 호출자(ElasticsearchAutoConnector)라서, 현재 규모에서는 분리 이점보다 추적 비용이 큽니다. ElasticsearchAutoConnector로 응집시키면 탐색 경로가 짧아집니다.

